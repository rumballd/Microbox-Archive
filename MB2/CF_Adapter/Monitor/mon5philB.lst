                       NAM Mon09
                       STTL Ver 5.0B    Ph. Roehr   27/04/2025
                      ;******************************************
                      ;******************************************
                      ;** MON09  Ver 5.0B                      **
                      ;** Original design Micro Concepts 1985  **
                      ;**                                      **
                      ;** Compact Flash adaptation 2025        **
                      ;** by Ph. Roehr                         **
                      ;**                                      **
                      ;******************************************
                      ;******************************************
                      ;*
                      ;******************************************
                      ;* This program is the core section of a  *
                      ;* general 6809(E) system monitor. It can *
                      ;* be configured to a particular system   *
                      ;* at assembly time by including on the   *
                      ;* source disk libary files containing    *
                      ;* the system specific code for the disk  *
                      ;* and console drivers and extra commands *
                      ;* and subroutines. These files are:-     *
                      ;*  SCRATCH.....Contains RMB's for extra  *
                      ;*              temp storage.             *
                      ;*  FDB.........Contains the jump table   *
                      ;*              entries for extra subs.   *
                      ;*  COMTABLE....Contains the extra jump   *
                      ;*              table entries for commands*
                      ;*  MINIT.......Contains the power on     *
                      ;*              and reset code.           *
                      ;*  CONSOLE.....Contains the console      *
                      ;*              driver code.              *
                      ;*  DISK........Contains the disk driver  *
                      ;*              code.                     *
                      ;*  SUBS........Contains the code for any *
                      ;*              extra system subroutines. *
                      ;*  BOOT........Contains the boot routine.*
                      ;*  COMMANDS....Contains the code for any *
                      ;*              extra commands.           *
                      ;******************************************
                      ;*
                      ;*
                      ;*
                      ;**************************
                      ;* Common System Equates  *
                      ;**************************
                      ;*
                      ;* LIB STARTADD
                      ;*
                      ;* FLEX variables ?
                      ;*
 CC00                 TTYBS   EQU   $CC00
 D3E5                 CINCHN  EQU   $D3E5        ; FLEX ?
                      ;*
                      ;* Other addresses
                      ;*
 E000                 PROM    EQU   $E000        ; Start of PROM
 CD00                 COLDS   EQU   $CD00        ; FLEX Cold Start
 CA00                 TXTRAM  EQU   $CA00        ; TEXT RAM
 CA02                 MCA02   EQU   $CA02        ; ?
                      ;*
 DE00                 RAM     EQU   $DE00        ; Scratch ram + stack space.
 FF00                 IO      EQU   $FF00        ; base address.
 DE6F                 SSTACK  EQU   (RAM+127-16) ; Top of system stack.
 DF80                 SCRAT   EQU   (RAM+384)    ; Start of scratch space.
                      ;*
                      ;* I/O
                      ;*
 FF00                 PIA1    EQU   IO           ; $FF00
 FF02                 SYSREG  EQU   PIA1+2       ; $FF02
 FF04                 ACIA2   EQU   IO+4         ; $FF04
 FF08                 ACIA1   EQU   IO+8         ; $FF08
 FF0C                 BAUD    EQU   IO+12        ; $FF0C
 FF10                 COMREG  EQU   IO+16        ; $FF10 : FDC Control register
 FF13                 DATREG  EQU   COMREG+3     ; $FF13 : FDC Data register
 FF14                 GDC     EQU   IO+20        ; $FF14
 FF18                 RTC     EQU   IO+24        ; $FF18
 FF1C                 PIA2    EQU   IO+28        ; $FF1C
                      ;*
                      ;* SAM Registers
                      ;*
 FFD6                 CLR_R0  EQU   $FFD6
 FFD7                 SET_R0  EQU   $FFD7
 FFD8                 CLR_R1  EQU   $FFD8
 FFD9                 SET_R1  EQU   $FFD9

                      ;*********************************
                      ;* Compact Flash System Equates  *
                      ;*********************************

                      ;* ABSOLUTE PIA PORT ADDRESSES

 FF1C                 PORTA               EQU     PIA2
 FF1D                 PORTB               EQU     PIA2+1
 FF1E                 PORTC               EQU     PIA2+2
 FF1F                 PORTCTRL            EQU     PIA2+3

                      ;* PIA CONTROL BYTES FOR READ AND WRITE TO IDE DRIVE

 0092                 RD_IDE_8255         EQU     $92     ; %10010010 PORT C CTRL OUT, PORT A/B DATA INPUT
 0080                 WR_IDE_8255         EQU     $80     ; %10000000 ALL 3 PORTS OUTPUT

                      ;* PIA CTRL PORT BIT FUNCTIONS

 0001                 IDE_A0              EQU     $01
 0002                 IDE_A1              EQU     $02
 0004                 IDE_A2              EQU     $04
 0008                 IDE_CS0             EQU     $08     ; INVERTED ON BOARD - SO SET FOR SELECT
 0010                 IDE_CS1             EQU     $10     ; INVERTED - SO SET FOR SELECT
 0020                 IDE_WR              EQU     $20     ; INVERTED - SO SET FOR WRITE
 0040                 IDE_RD              EQU     $40     ; INVERTED - SO SET FOR READ
 0080                 IDE_RST             EQU     $80     ; INVERTED - SO SET FOR RESET

                      ; COMPACT FLASH REGISTER CONSTANTS FOR A BETTER READING OF THE CODE

 0008                 IDE_DATA            EQU     IDE_CS0                      ; DATA R/W
 0009                 IDE_ERR             EQU     IDE_CS0+IDE_A0               ; READ ERROR CODE
 0009                 IDE_SET_FEAT        EQU     IDE_CS0+IDE_A0               ; WRITE FEATURE
 000A                 IDE_SEC_CNT         EQU     IDE_CS0+IDE_A1               ; NUMBER OF SECTORS TO TRANSFER
 000B                 IDE_LBA0            EQU     IDE_CS0+IDE_A1+IDE_A0        ; SECTOR ADDRESS LBA 0 [BITS 0:7]
 000C                 IDE_LBA1            EQU     IDE_CS0+IDE_A2               ; SECTOR ADDRESS LBA 1 [BITS 8:15]
 000D                 IDE_LBA2            EQU     IDE_CS0+IDE_A2+IDE_A0        ; SECTOR ADDRESS LBA 2 [BITS 16:23]
 000E                 IDE_LBA3            EQU     IDE_CS0+IDE_A2+IDE_A1        ; SECTOR ADDRESS LBA 3 [BITS 24:27 (LSB)]
 000F                 IDE_COMMAND         EQU     IDE_CS0+IDE_A2+IDE_A1+IDE_A0 ; WRITE COMMAND
 000F                 IDE_STATUS          EQU     IDE_CS0+IDE_A2+IDE_A1+IDE_A0 ; READ CF STATUS

                      ;* IDE COMMAND CONSTANTS. THESE SHOULD NEVER CHANGE.

 0020                 IDE_CMD_READ        EQU     $20                 ; READ A LBA
 0030                 IDE_CMD_WRITE       EQU     $30                 ; WRITE A LBA
 00EF                 IDE_CMD_SET_FEAT    EQU     $EF                 ; SET FEATURES

                      ;* FEATURE REQUESTS

 0081                 IDE_FEA_16BIT       EQU     $81
 00E0                 LBA3MST             EQU     $E0                 ; LBA3 FOR IDE MASTER
 00F0                 LBA3SLV             EQU     $F0                 ; LBA3 FOR IDE SLAVE

                      ; CF CONTROL BITS

 0008                 DRQBIT              EQU     %00001000           ; DATA REQUEST BIT = CF STATUS BIT 3
 0040                 RDYBIT              EQU     %01000000           ; READY BIT = BIT 6
 0080                 BSYBIT              EQU     %10000000           ; BUSY BIT = BIT 7
 0001                 ERRBIT              EQU     %00000001           ; ERROR BIT = BIT 0

                      ;**************************
                      ;* scratch storage space  *
                      ;**************************

                      ;* PARAMS TABLE FOR CF

                              ORG   (RAM+128-8)

 DE78                 SETFEA  RMB   1          ; SET FEATURE 16 BITS MODE
 DE79                 SCTCNT  RMB   1          ; SECTOR COUNT FOR R/W (ALWAYS 1)
 DE7A                 LBA0    RMB   1          ; LBA7 TO LBA0
 DE7B                 LBA1    RMB   1          ; LBA15 TO LBA8
 DE7C                 LBA2    RMB   1          ; LBA23 TO LBA 16
 DE7D                 LBA3    RMB   1          ; B7=1 / B6=1 FOR LBA / B5=1 / B4=0 MASTER B4=1 SLAVE / B3->B0 LBA27 TO LBA24
 DE7E                 MSTCFOK RMB   1          ; CF PRESENT FLAGS BY DEFAULT NOT
 DE7F                 SLVCFOK RMB   1          ; BOTH SET BY INITCF ROUTINE

                              ORG   (RAM+128)

 DE80                 BUFFER  RMB   256          ; Floppy interface sector buffer.

                              ORG   SCRAT

 DF80                 STACK   RMB   2            ; User system stack.
 DF82                 NMIV    RMB   2            ; NMI interrupt vector.
 DF84                 IRQV    RMB   2            ; IRQ interrupt vector.
 DF86                 FIRQV   RMB   2            ; FIRQ interrupt vector.
 DF88                 SWI2V   RMB   2            ; SWI2 interrupt vector.
 DF8A                 SWI3V   RMB   2            ; SWI3 interrupt vector.
 DF8C                 IPORT   RMB   1            ; Active input port.
 DF8D                 OPORT   RMB   1            ; Active output port.
 DF8E                 DRIVE   RMB   1            ; Format drive value.
 DF8F                 TRACK   RMB   1            ; Format track value.
 DF90                 SECTOR  RMB   1            ; Format sector value.
 DF91                 TEMP    RMB   1
 DF92                 XTEMP   RMB   2
 DF94                 YTEMP   RMB   2
 DF96                 TTO     RMB   2
 DF98                 RNDM    RMB   4            ; Random number storage.
 DF9C                 WARMS   RMB   1            ; Warm start flag.
 DF9D                 DDSTAB  RMB   4            ; Disc driver type table.
 DFA1                 REAVEC  RMB   2            ; Disc driver jump tables.
 DFA3                 WRIVEC  RMB   2
 DFA5                 VERVEC  RMB   2
 DFA7                 RSTVEC  RMB   2
 DFA9                 DRVVEC  RMB   2
 DFAB                 CHKVEC  RMB   2
 DFAD                 QUIVEC  RMB   2
 DFAF                 INIVEC  RMB   2
 DFB1                 WARVEC  RMB   2
 DFB3                 SEEVEC  RMB   2

                      ;*********************************************
                      ;* Extra scratch space for system dependant  *
                      ;* routines fits here.                       *
                      ;*********************************************
                      ;* LIB SCRATCH
                      ;*
 DFB5                 RTCFAIL EQU   $DFB5        ; ?
 DFB6                 CURDRV  EQU   $DFB6        ; ?
 DFB7                 XCOORD  EQU   $DFB7        ; ?
 DFB9                 YCOORD  EQU   $DFB9        ; ?
 DFBB                 PART1   EQU   $DFBB        ; ?
 DFBF                 PART2   EQU   $DFBF        ; ?
 DFC3                 GPARAM  EQU   $DFC3        ; ?
 DFC4                 MDFC4   EQU   $DFC4        ; ?
 DFCB                 GMODE   EQU   $DFCB        ; ?
 DFCC                 GZOOM   EQU   $DFCC        ; ?
 DFCD                 GFIGS   EQU   $DFCD        ; ?
 DFCE                 DN      EQU   $DFCE        ; ?
 DFD0                 D0      EQU   $DFD0        ; ?
 DFD1                 D1      EQU   $DFD1        ; ?
 DFD2                 D2      EQU   $DFD2        ; ?
 DFD4                 D4      EQU   $DFD4        ; ?
 DFD6                 DM      EQU   $DFD6        ; ?
 DFD8                 CONST   EQU   $DFD8        ; ?
 DFD9                 ROW     EQU   $DFD9        ; ?
 DFDA                 COL     EQU   $DFDA        ; ?
 DFE1                 ATTRI   EQU   $DFE1        ; ?
 DFE5                 CURSOR  EQU   $DFE5        ; ?
 DFEA                 CTYPE   EQU   $DFEA        ; ?
 DFEB                 ESCFLG  EQU   $DFEB        ; ?
 DFEC                 TS1     EQU   $DFEC        ; ?
 DFEE                 TS2     EQU   $DFEE        ; ?
 DFF0                 TL1     EQU   $DFF0        ; ?
 DFF2                 TL2     EQU   $DFF2        ; ?
 DFF4                 DEN     EQU   $DFF4        ; Density
 DFF5                 DEN1    EQU   $DFF5
 DFF6                 STEP    EQU   $DFF6        ; Floppy stepping speed
 DFF7                 SPEED   EQU   $DFF7        ; SAM speed setting
 DFF8                 TSTEP   EQU   $DFF8        ; ?
 DFF9                 PSPEED  EQU   $DFF9        ; ?
 DFFA                 MDFFA   EQU   $DFFA        ; ?
 DFFB                 DROMSZ  EQU   $DFFB        ; !!! NOT RELEVANT IN THIS VERSION !!!
 DFFC                 REGDP   EQU   $DFFC        ; Current DP Register
 DFFD                 FLASH   EQU   $DFFD        ; ?
 DFFF                 BLANKD  EQU   $DFFF        ; ?
                      ;*
                      ;*********************************
                      ;* Monitor part of PROM, disabled when FLEX is running
                      ;*********************************

                              ORG     PROM

                      ;* LIB MINIT
 E000 0A0D            HDR     FCB     $0A,$0D
 E002 2B2B2B204D6F6E          FCC     '+++ Mon09 Ver 5.0 Ph. Roehr 2025 +++'
 E009 30392056657220
 E010 352E302050682E
 E017 20526F65687220
 E01E 32303235202B2B
 E025 2B
 E026 04                      FCB     $04
 E027 0A0D            PROMPT  FCB     $0A,$0D
 E029 3D3E                    FCC     '=>'
 E02B 04                      FCB     $04
 E02C 07              NOTTHS  FCB     $07
 E02D 20556E6B6E6F77          FCC     ' Unknown command! '
 E034 6E20636F6D6D61
 E03B 6E642120
 E03F 04                      FCB     $04
 E040 070707070707    UNMESS  FCB     $07,$07,$07,$07,$07,$07
 E046 07070707                FCB     $07,$07,$07,$07
 E04A 554E4558504543          FCC     'UNEXPECTED INTERUPT!!!!!!!!!!'
 E051 54454420494E54
 E058 45525550542121
 E05F 21212121212121
 E066 21
 E067 04                      FCB     $04
 E068 070707          PFAIL   FCB     $07,$07,$07
 E06B 506F7765722066          FCC     'Power failure in RTC, reloading defaults'
 E072 61696C75726520
 E079 696E205254432C
 E080 2072656C6F6164
 E087 696E6720646566
 E08E 61756C7473
 E093 04                      FCB     $04
 E094 4D617374657220  CFMST   FCC     'Master CF detected'
 E09B 43462064657465
 E0A2 63746564
 E0A6 04                      FCB     $04
 E0A7 536C6176652043  CFSLV   FCC     'Slave CF detected'
 E0AE 46206465746563
 E0B5 746564
 E0B8 04                      FCB     $04
                      ;*
                      ;* default values for RTC RAM
                      ;*
 E0B9 50FF010002      TCONST  FCB     $50,$FF,$01,$00,$02
 E0BE 0308003A00              FCB     $03,$08,$00,$3A,$00
 E0C3 5000000800              FCB     $50,$00,$00,$08,$00
 E0C8 001B00011F              FCB     $00,$1B,$00,$01,$1F
 E0CD 2E65080604              FCB     $2E,$65,$08,$06,$04
 E0D2 2041000000              FCB     $20,$41,$00,$00,$00
 E0D7 0000000000              FCB     $00,$00,$00,$00,$00
 E0DC 0000000000              FCB     $00,$00,$00,$00,$00
 E0E1 0000000000              FCB     $00,$00,$00,$00,$00
 E0E6 0000000000              FCB     $00,$00,$00,$00,$00
                      ;*
                      ;* System dependant init : part 2 of RESET routine
                      ;*
 E0EB BFDF98          MINIT1  STX     RNDM
 E0EE C60D                    LDB     #$0D
 E0F0 BDF5EA                  JSR     GETRTC     ; read D-reg
 E0F3 8480                    ANDA    #$80       ; mask off bit 0-6
 E0F5 B7DFB5                  STA     RTCFAIL    ; =0 if no power
 E0F8 B6FF02                  LDA     SYSREG
 E0FB 43                      COMA
 E0FC 44                      LSRA
 E0FD 44                      LSRA
 E0FE 44                      LSRA
 E0FF 44                      LSRA
 E100 1F89                    TFR     A,B
 E102 C401                    ANDB    #$01
 E104 F7DF8C                  STB     IPORT
 E107 1F89                    TFR     A,B
 E109 54                      LSRB
 E10A C401                    ANDB    #$01
 E10C F7DF8D                  STB     OPORT
 E10F 7DDFB5                  TST     RTCFAIL
 E112 260F                    BNE     INIT2      ; RTC data valid ?
 E114 8EE0B9                  LDX     #TCONST    ; no, so get default values
 E117 C60E                    LDB     #$0E
 E119 A680            IRTC    LDA     ,X+
 E11B BDF608                  JSR     PUTRTC
 E11E 5C                      INCB
 E11F C140                    CMPB    #$40
 E121 26F6                    BNE     IRTC
 E123 C60E            INIT2   LDB     #$0E       ; get RTC saved data
 E125 BDF5EA                  JSR     GETRTC
 E128 1F89                    TFR     A,B
 E12A 8480                    ANDA    #$80
 E12C B7DFF9                  STA     PSPEED     ; init cpu speed (?)
 E12F 1F98                    TFR     B,A
 E131 8440                    ANDA    #$40
 E133 B7DFFA                  STA     MDFFA      ; init ?
 E136 1F98                    TFR     B,A
 E138 8430                    ANDA    #$30
 E13A 48                      ASLA
 E13B 48                      ASLA
 E13C 84C0                    ANDA    #$C0
 E13E B7DFFB                  STA     DROMSZ     ; !!! NOT RELEVANT IN THIS VERSION !!!
 E141 1F98                    TFR     B,A
 E143 840C                    ANDA    #$0C
 E145 44                      LSRA
 E146 44                      LSRA
 E147 B7DFF7                  STA     SPEED      ; init cpu speed
 E14A 1F98                    TFR     B,A
 E14C 8403                    ANDA    #$03
 E14E B7DFF8                  STA     TSTEP      ; init disc step speed
 E151 4F                      CLRA
 E152 BBDFF7                  ADDA    SPEED
 E155 B7FF10                  STA     COMREG
 E158 7DDFF9                  TST     PSPEED
 E15B 2703                    BEQ     INIT3
 E15D B7FFD9                  STA     SET_R1     ; init SAM values for FAST/SLOW
 E160 86CE            INIT3   LDA     #$CE
 E162 B7FF09                  STA     ACIA1+1    ; init acia 1 and 2
 E165 B7FF05                  STA     ACIA2+1    ; 2 stop bits,no parity,8 bits,baud rate factor=X16
 E168 8627                    LDA     #$27
 E16A B7FF09                  STA     ACIA1+1    ; enable reciever & transmitter
 E16D B7FF05                  STA     ACIA2+1
 E170 C60F                    LDB     #$0F
 E172 BDF5EA                  JSR     GETRTC
 E175 B7FF0C                  STA     BAUD       ; 9600 baud
 E178 44                      LSRA
 E179 44                      LSRA
 E17A 44                      LSRA
 E17B 44                      LSRA
 E17C B7FF0D                  STA     BAUD+1
 E17F BDF8D3                  JSR     GDCINI     ; init graphic controler
 E182 869B                    LDA     #$9B
 E184 B7FF1F                  STA     PIA2+3
 E187 C610                    LDB     #$10
 E189 8EDF9D                  LDX     #DDSTAB    ; load disc drive table
 E18C BDF5EA          INIT4   JSR     GETRTC
 E18F A780                    STA     ,X+
 E191 5C                      INCB
 E192 C114                    CMPB    #$14
 E194 26F6                    BNE     INIT4
 E196 7DDFB5                  TST     RTCFAIL    ; message if RTC data not valid
 E199 2606                    BNE     RTCOK
 E19B 8EE068                  LDX     #PFAIL
 E19E BDF525                  JSR     PSTRNG

                      ;* IDE/CF detection and init
 E1A1 8619            RTCOK   LDA     #25
 E1A3 BDEFD2                  JSR     WAIT1MS    ; wait 25 ms after power on
 E1A6 8692                    LDA     #RD_IDE_8255
 E1A8 B7FF1F                  STA     PORTCTRL   ; set port C as output
 E1AB 8680                    LDA     #IDE_RST   ; do a ide bus reset
 E1AD B7FF1E                  STA     PORTC
 E1B0 860A                    LDA     #10        ; keep reset low > 25 Âµs
 E1B2 4A              LOOPRST DECA
 E1B3 26FD                    BNE     LOOPRST
 E1B5 7FFF1E                  CLR     PORTC
 E1B8 8605                    LDA     #5
 E1BA BDEFD2                  JSR     WAIT1MS    ; wait 5 ms for cf to complete init
 E1BD CC0000                  LDD     #$0000     ; init ram cf table
 E1C0 FDDE7E                  STD     MSTCFOK    ; clear both cf present flags
 E1C3 8681                    LDA     #IDE_FEA_16BIT      ; prepare for 16 bits mode
 E1C5 B7DE78                  STA     SETFEA
 E1C8 8601                    LDA     #$01       ; prepare for rw 1 sector at a time
 E1CA B7DE79                  STA     SCTCNT
 E1CD 86E0                    LDA     #LBA3MST   ; prepare for master cf
 E1CF B7DE7D                  STA     LBA3
 E1D2 7FDE7C                  CLR     LBA2       ; set all lba's to 0
 E1D5 7FDE7B                  CLR     LBA1
 E1D8 7FDE7A                  CLR     LBA0
 E1DB BDF45F                  JSR     INIDT2     ; init typ 2/3 disk
 E1DE 7DDE7E                  TST     MSTCFOK    ; master cf ok ?
 E1E1 2711                    BEQ     CONTINI    ; no continue init
 E1E3 8EE094                  LDX     #CFMST     ; display master cf message
 E1E6 BDF525                  JSR     PSTRNG
 E1E9 7DDE7F                  TST     SLVCFOK    ; slave cf ok ?
 E1EC 2706                    BEQ     CONTINI    ; no continue init
 E1EE 8EE0A7                  LDX     #CFSLV     ; display slave cf message
 E1F1 BDF525                  JSR     PSTRNG
                      ;* End of IDE/CF init

 E1F4 B6FF02          CONTINI LDA     SYSREG
 E1F7 43                      COMA               ; autoboot ?
 E1F8 102B012C                LBMI    BO         ; yes, boot FLEX
 E1FC 7EF0D9                  JMP     MINITR     ; no, go to monitor
                      ;*
                      ;***************************
                      ;* Jump table for commands *
                      ;***************************
 E1FF 4844            COMTAB  FCC     'HD' ; Hex dump .
 E201 E5D2                    FDB     HD
 E203 4452                    FCC     'DR' ; Display cpu registers.
 E205 E75A                    FDB     DR
                      *
 E207 5342                    FCC     'SB' ; Set baud rate for acia's.
 E209 EDF4                    FDB     SB
 E20B 5349                    FCC     'SI' ; Set input port.
 E20D E2C3                    FDB     SI
 E20F 534F                    FCC     'SO' ; Set output port.
 E211 E2E9                    FDB     SO
 E213 4344                    FCC     'CD' ; Calculate two's complement branch length.
 E215 E4A0                    FDB     CD
                      *
 E217 5250                    FCC     'RP' ; Run program .
 E219 E560                    FDB     RP
 E21B 4A55                    FCC     'JU' ; Jump to program .
 E21D E27D                    FDB     JU
 E21F 4A46                    FCC     'JF' ; Jump to flex warm start ($CD03).
 E221 E2A3                    FDB     JF
 E223 4350                    FCC     'CP' ; Continue program after SWI.
 E225 E4F6                    FDB     CP
                      *
 E227 4D45                    FCC     'ME' ; Memory examine and alter .
 E229 E6E0                    FDB     ME
 E22B 504D                    FCC     'PM' ; Poke memory with value (no verify of data).
 E22D E645                    FDB     PM
 E22F 4C4B                    FCC     'LK' ; Load ascii text from keyboard .
 E231 E687                    FDB     LK
 E233 534D                    FCC     'SM' ; Shift a block of memory .
 E235 E7AF                    FDB     SM
 E237 464D                    FCC     'FM' ; Fill memory with a constant value.
 E239 E522                    FDB     FM
 E23B 4649                    FCC     'FI' ; Find ascii string.
 E23D ED1E                    FDB     FI
                      *
 E23F 544D                    FCC     'TM' ; Quick memory test.
 E241 E825                    FDB     TM
 E243 5453                    FCC     'TS' ; Drive stepping and select test.
 E245 EBF6                    FDB     TS
 E247 5444                    FCC     'TD' ; Test random read on drive.
 E249 EB75                    FDB     TD
                      *
 E24B 424F                    FCC     'BO' ; Boot FLEX.COR or FLEX.SYS from logical drive 0
 E24D E328                    FDB     BO
 E24F 5253                    FCC     'RS' ; Read sector from floppy.
 E251 E8E2                    FDB     RS
 E253 5753                    FCC     'WS' ; Write sector to floppy.
 E255 E956                    FDB     WS
 E257 4446                    FCC     'DF' ; Format disc to FLEX format.
 E259 E9E9                    FDB     DF
                      ;*
                      ;*************************************
                      ;* Extra system dependant command    *
                      ;* entries fit here.                 *
                      ;*************************************
                      ;* LIB COMTABLE
                      ;*
 E25B 4246                    FCC     'BF' ; Boot Flex from floppy 0 regardless of allocation
 E25D EC1B                    FDB     BF
 E25F 4443                    FCC     'DC' ; Display RTC contents
 E261 EC3B                    FDB     DC
 E263 4D43                    FCC     'MC' ; RTC examine and alter
 E265 ECAB                    FDB     MC
                      ;*
 E267 FF                      FCB     $FF  ; End of table flag.
                      ;*
                      ;***************************
                      ;* Common system commands. *
                      ;***************************
                      ;*
                      ;* Jump to program.
 E268 0D4A756D702074  JUMES   FCB     $0D,"Jump to program at ",4
 E26F 6F2070726F6772
 E276 616D2061742004

 E27D 8EE268          JU      LDX     #JUMES
 E280 BDF51E                  JSR     PDATA1
 E283 BDF55C                  JSR     BADDR
 E286 7EF637                  JMP     MAPOUT
                      ;*
                      ;* Jump to flex warm start.
 E289 0D4A756D702074  JFMES   FCB     $0D,"Jump to flex warm start.",4
 E290 6F20666C657820
 E297 7761726D207374
 E29E 6172742E04

 E2A3 8EE289          JF      LDX     #JFMES
 E2A6 BDF51E                  JSR     PDATA1
 E2A9 8ECD03                  LDX     #$CD03
 E2AC 7EF637                  JMP     MAPOUT
                      ;*
                      ;* Set input port.
 E2AF 0D53657420696E  SIMES   FCB     $0D,"Set input port to ",4
 E2B6 70757420706F72
 E2BD 7420746F2004

 E2C3 8EE2AF          SI      LDX     #SIMES
 E2C6 BDF51E                  JSR     PDATA1
 E2C9 BDF58C                  JSR     INHEX
 E2CC 8403                    ANDA    #$03
 E2CE B7DF8C                  STA     IPORT
 E2D1 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Set output port.
 E2D4 0D536574206F75  SOMES   FCB     $0D,"Set output port to ",4
 E2DB 7470757420706F
 E2E2 727420746F2004

 E2E9 8EE2D4          SO      LDX     #SOMES
 E2EC BDF51E                  JSR     PDATA1
 E2EF BDF58C                  JSR     INHEX
 E2F2 8403                    ANDA    #$03
 E2F4 B7DF8D                  STA     OPORT
 E2F7 7EF0DF                  JMP     CONTRL
                      ;*
                      ;********************************
                      ;*    System specific Boot      *
                      ;*    command goes here.        *
                      ;********************************
                      ;* LIB BOOT
 E2FA 0D              BOMES   FCB     $0D
 E2FB 426F6F74696E67          FCC     "Booting FLEX...."
 E302 20464C45582E2E
 E309 2E2E
 E30B 04                      FCB     $04
 E30C 0A0D07          NOFLX   FCB     $0A,$0D,$07
 E30F 43616E27742066          FCC     "Can't find FLEX!" ; Can't find FLex
 E316 696E6420464C45
 E31D 5821
 E31F 04                      FCB     $04
 E320 464C4558        BODIS   FCC     "FLEX"
 E324 00000000                FCB     $00,$00,$00,$00

                      ;* Action BO (BOot flex from logical drive 0)
 E328 8EE2FA          BO      LDX     #BOMES     ; send message
 E32B BDF51E                  JSR     PDATA1
 E32E 7FDF8E                  CLR     DRIVE      ; select drive 0
 E331 8EDF8B                  LDX     #DRIVE-3
 E334 BDF4AE                  JSR     RST        ; drive select and track 0
 E337 C605                    LDB     #$05       ; sector 5
 E339 F7DF90                  STB     SECTOR
 E33C 4F                      CLRA
 E33D B7DF8F                  STA     TRACK      ; (start of directory)
 E340 F6DF90          BO1     LDB     SECTOR
 E343 B6DF8F                  LDA     TRACK
 E346 8EDE80                  LDX     #BUFFER    ; point to buffer
 E349 BDF4A2                  JSR     READ       ; read sector
 E34C 8EDE90                  LDX     #BUFFER+16 ; point to 1st name
 E34F C60A                    LDB     #$0A       ; names per sector
 E351 108EE320        BO2     LDY     #BODIS     ; (compare template)
 E355 3410                    PSHS    X          ; save addr of name
 E357 A680            BO3     LDA     ,X+        ; compare characters
 E359 A1A0                    CMPA    ,Y+
 E35B 260D                    BNE     BO4        ; match ?
 E35D 108CE328                CMPY    #BO        ; yes,all done ?
 E361 26F4                    BNE     BO3        ; no,compare next
 E363 EC05                    LDD     $05,X      ; yes,get start addr
 E365 FDDF94                  STD     YTEMP      ; of file & store it
 E368 201D                    BRA     RDSEC      ; go and load it
 E36A 5A              BO4     DECB               ; no match.next name
 E36B 2707                    BEQ     BO5        ; end of sector ?
 E36D 3510                    PULS    X          ; no,recover name addr
 E36F 308818                  LEAX    $18,X      ; point to next name
 E372 20DD                    BRA     BO2        ; and try again
 E374 FCDE80          BO5     LDD     BUFFER     ; next dir sector
 E377 2705                    BEQ     BOFAIL     ; end of directory ?
 E379 FDDF8F                  STD     TRACK      ; no,update T/S addr
 E37C 20C2                    BRA     BO1        ; and try again
 E37E 8EE30C          BOFAIL  LDX     #NOFLX     ; yes,failed !
 E381 BDF525                  JSR     PSTRNG     ; send error message
 E384 7EF0DF                  JMP     CONTRL     ; and back to Mono9
                      * Load Flex.sys
 E387 FCDF94          RDSEC   LDD     YTEMP      ; (T/S adr. of file)
 E38A FDDE80                  STD     BUFFER     ; put in buffer
 E38D 108EDF80                LDY     #BUFFER+256
 E391 8D34            BOFL1   BSR     NEXTB
 E393 8102                    CMPA    #$02       ; binary record ?
 E395 270A                    BEQ     BOFL2      ; yes,go set TTO
 E397 8116                    CMPA    #$16       ; transfer addr ?
 E399 26F6                    BNE     BOFL1      ; cont.until 02 or 16
 E39B 8D2A                    BSR     NEXTB      ; it was a transfer addr
 E39D 8D28                    BSR     NEXTB      ; Discard it and
 E39F 20F0                    BRA     BOFL1      ; find next record
 E3A1 8D24            BOFL2   BSR     NEXTB      ; get load adr.Hi
 E3A3 B7DF96                  STA     TTO
 E3A6 8D1F                    BSR     NEXTB      ; get load adr.Lo
 E3A8 B7DF97                  STA     TTO+1
 E3AB 8D1A                    BSR     NEXTB      ; get byte count
 E3AD 1F89                    TFR     A,B        ; put it in ACC B
 E3AF 5D                      TSTB               ; if 0, end of record
 E3B0 27DF                    BEQ     BOFL1      ; go find next rec
 E3B2 BEDF96                  LDX     TTO        ; else,copy to [TTO]
 E3B5 3414            BOFL3   PSHS    X,B        ; save count & adr
 E3B7 8D0E                    BSR     NEXTB      ; get a byte
 E3B9 3514                    PULS    X,B        ; recall cnt.& adr skip
 E3BB 8CDE00                  CMPX    #RAM       ; Microbox loads
 E3BE 2202                    BHI     BOFL4      ; this area from tables
 E3C0 A780                    STA     ,X+
 E3C2 5A              BOFL4   DECB               ; end of record ?
 E3C3 26F0                    BNE     BOFL3      ; no,continue
 E3C5 20CA                    BRA     BOFL1      ; yes,find next rec

                      ;* This subroutine gets the next byte from the buffer
                      ;* into ACC A. If the buffer is empty,the next sector
                      ;* is first read into the buffer. If all sectors have
                      ;* been read,a branch to 'Read tables & Exit' occures.
                      ;*
 E3C7 108CDF80        NEXTB   CMPY    #BUFFER+256
 E3CB 2610                    BNE     NEXT2      ; buffer empty ?
 E3CD 8EDE80                  LDX     #BUFFER    ; yes,read next sector
 E3D0 EC84                    LDD     ,X         ; look at link adr
 E3D2 270C                    BEQ     LDTBL      ; no more, do tables
 E3D4 BDF4A2                  JSR     READ
                      ;* If read error,density setting is toggled so try again
 E3D7 26AE                    BNE     RDSEC      ; error if not 0
 E3D9 108EDE84                LDY     #BUFFER+4  ; point to name
 E3DD A6A0            NEXT2   LDA     ,Y+
 E3DF 39                      RTS
                      ;*
                      ;* Read Tables & Exit
                      ;*
 E3E0 8ED3E5          LDTBL   LDX     #CINCHN    ; load table 1
 E3E3 108EE41F                LDY     #TABLE1
 E3E7 ECA1            LDTB1   LDD     ,Y++
 E3E9 ED81                    STD     ,X++
 E3EB 8CD3FD                  CMPX    #$D3FD
 E3EE 26F7                    BNE     LDTB1
 E3F0 8EDE00                  LDX     #RAM
 E3F3 108EE437                LDY     #TABLE2    ; load table 2
 E3F7 ECA1            LDTB2   LDD     ,Y++
 E3F9 ED81                    STD     ,X++
 E3FB 8CDE1E                  CMPX    #$DE1E
 E3FE 26F7                    BNE     LDTB2
 E400 8639                    LDA     #$39
 E402 B7CA02                  STA     MCA02
 E405 7DDFB5                  TST     RTCFAIL    ; valid data ?
 E408 270F                    BEQ     GOFLX      ; no,ignore
 E40A 8ECC00                  LDX     #TTYBS     ; else,copy in
 E40D C614                    LDB     #$14       ; TTYSET & ASN options
 E40F BDF5EA          CPRTC   JSR     GETRTC
 E412 A780                    STA     ,X+
 E414 5C                      INCB
 E415 C121                    CMPB    #$21
 E417 26F6                    BNE     CPRTC
 E419 8ECD00          GOFLX   LDX     #COLDS     ; select Cold Start
 E41C 7EF637                  JMP     MAPOUT     ; and jump to it
                      ;*
                      ;* Table 1 : console I/O
                      ;*
 E41F F153            TABLE1  FDB     INCH1
 E421 F130                    FDB     DUMMY
 E423 FFFE                    FDB     VCRST
 E425 FFFE                    FDB     VCRST
 E427 F130                    FDB     DUMMY
 E429 F130                    FDB     DUMMY
 E42B F130                    FDB     DUMMY
 E42D F0DF                    FDB     CONTRL
 E42F F130                    FDB     DUMMY
 E431 F131                    FDB     STATUS
 E433 F16E                    FDB     OUTCH
 E435 F16C                    FDB     INCH
                      ;*
                      ;* Table 2 : disk I/O
 E437 7EF4A2          TABLE2  JMP     READ
 E43A 7EF4A6                  JMP     WRITE
 E43D 7EF4AA                  JMP     VERIFY
 E440 7EF4AE                  JMP     RST
 E443 7EF4B7                  JMP     DRV
 E446 7EF4E7                  JMP     CHKRDY
 E449 7EF4EB                  JMP     QUICK
 E44C 7EF4EF                  JMP     DINIT
 E44F 7EF507                  JMP     WARM
 E452 7EF50B                  JMP     SEEK
                      ;*
                      ;*         Calculate displacement.
 E455 0D43616C63756C  CALDIS  FCB     $0D,"Calculate displacement from ",4
 E45C 61746520646973
 E463 706C6163656D65
 E46A 6E742066726F6D
 E471 2004
 E473 20746F2004      TOS     FCB     " to ",4
 E478 0D0A204C6F6E67  CALD1   FCB     $0D,$0A," Long or short branch (L/S)? ",4
 E47F 206F722073686F
 E486 7274206272616E
 E48D 636820284C2F53
 E494 293F2004
 E498 2076616C756520  VALUES  FCB     " value ",4
 E49F 04

 E4A0 8EE455          CD      LDX     #CALDIS
 E4A3 BDF51E                  JSR     PDATA1
 E4A6 BDF55C                  JSR     BADDR      ; get 'from'
 E4A9 3002                    LEAX    2,X        ; add 2
 E4AB 3410                    PSHS    X          ; save it
 E4AD 8EE473                  LDX     #TOS
 E4B0 BDF51E                  JSR     PDATA1
 E4B3 BDF55C                  JSR     BADDR      ; get 'to'
 E4B6 1F12                    TFR     X,Y        ; save in Y
 E4B8 8EE478                  LDX     #CALD1
 E4BB BDF51E                  JSR     PDATA1
 E4BE BDF16C                  JSR     INCH       ; get 'L/S'
 E4C1 814C                    CMPA    #'L'       ; was it L ?
 E4C3 2606                    BNE     CD1        ; no,branch
 E4C5 3510                    PULS    X          ; recall 'from'
 E4C7 3002                    LEAX    2,X        ; add 2
 E4C9 3410                    PSHS    X          ; save again
 E4CB 1F20            CD1     TFR     Y,D        ; D = 'to'
 E4CD A3E4                    SUBD    ,S         ; subtract 'from'
 E4CF EDE4                    STD     ,S         ; 'offset' now TO S
 E4D1 8EE498                  LDX     #VALUES
 E4D4 BDF51E                  JSR     PDATA1
 E4D7 3510                    PULS    X
 E4D9 BDF536                  JSR     PRINTX     ; 'offset'
 E4DC 7EF0DF                  JMP     CONTRL
                      ;*(its not format, the program just send a reset command and configure the cf, no relation with the datas stored)
                      ;* Continue program. [There is a BUG in this routine]
 E4DF 0D436F6E74696E  CONPRS  FCB     $0D,"Continue from SWI....",4
 E4E6 75652066726F6D
 E4ED 205357492E2E2E
 E4F4 2E04

 E4F6 8EE4DF          CP      LDX     #CONPRS
 E4F9 BDF51E                  JSR     PDATA1
 E4FC 6C6B                    INC     11,S       ; (PC-low)
 E4FE 7EE56F                  JMP     RP1        ; recover SP & RTI.
                      ;* BUG here? What if PC-low = $FF ???
                      ;* why not  LDX   10,S
                      ;* LEAX   1,X
                      ;* STX   10,S   ie. Increment PC.
                      ;*
                      ;* Fill memory with constant.
 E501 0D46696C6C206D  FILMES  FCB     $0D,"Fill memory with constant from ",4
 E508 656D6F72792077
 E50F 69746820636F6E
 E516 7374616E742066
 E51D 726F6D2004

 E522 8EE501          FM      LDX     #FILMES
 E525 BDF51E                  JSR     PDATA1
 E528 BDF55C                  JSR     BADDR      ; get 'from'
 E52B 1F12                    TFR     X,Y        ; save in Y
 E52D 8EE473                  LDX     #TOS
 E530 BDF51E                  JSR     PDATA1
 E533 BDF55C                  JSR     BADDR      ; get 'to'
 E536 3410                    PSHS    X          ; save in X
 E538 8EE498                  LDX     #VALUES
 E53B BDF51E                  JSR     PDATA1
 E53E BDF567                  JSR     BYTE       ; get 'value'
 E541 A7A0            FM1     STA     ,Y+        ; fill until
 E543 10ACE4                  CMPY    ,S         ; from = to
 E546 26F9                    BNE     FM1        ; then
 E548 3510                    PULS    X          ; tidy stack
 E54A 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Go to user routine at XXXX.
 E54D 0D52756E207072  RUNPRS  FCB     $0D,"Run program from ",4
 E554 6F6772616D2066
 E55B 726F6D2004

 E560 8EE54D          RP      LDX     #RUNPRS
 E563 BDF51E                  JSR     PDATA1
 E566 BDF55C                  JSR     BADDR      ; input start addr
 E569 AF6A                    STX     10,S       ; stack it as PC
 E56B 86FF                    LDA     #$FF
 E56D A7E4                    STA     ,S         ; stack as CC
 E56F 10FEDF80        RP1     LDS     STACK      ; recover SP
 E573 3B                      RTI                ; load all registers
                      ;*
                      ;* SWI return from user program.
 E574 10FFDF80        SWI     STS     STACK      ; save SP
 E578 AE6A                    LDX     10,S       ; get PC
 E57A 301F                    LEAX    -1,X       ; decrement it
 E57C AF6A                    STX     10,S       ; and put it back
 E57E 7EE760                  JMP     DR1        ; display registers
                      ;*
                      ;* Hexdump of memory starting at XXXX.
                      ;* @@ Modified 04/2025 PhR to get also ascii display on each line
 E581 0D486578206475  HEXDUS  FCB     $0D,"Hex dump of memory from ",4
 E588 6D70206F66206D
 E58F 656D6F72792066
 E596 726F6D2004
 E59B 20202020203020  HDMES1  FCB     "     0  1  2  3  4  5  6  7   8  9  A  B  C  D  E  F  ",4
 E5A2 20312020322020
 E5A9 33202034202035
 E5B0 20203620203720
 E5B7 20203820203920
 E5BE 20412020422020
 E5C5 43202044202045
 E5CC 202046202004

 E5D2 8EE581          HD      LDX     #HEXDUS
 E5D5 BDF51E                  JSR     PDATA1
 E5D8 BDF55C                  JSR     BADDR      ; get start addr
 E5DB BDF512                  JSR     PCRLF
 E5DE 108E0010        HD4     LDY     #16
 E5E2 BDF512                  JSR     PCRLF
 E5E5 3410                    PSHS    X
 E5E7 8EE59B                  LDX     #HDMES1
 E5EA BDF525                  JSR     PSTRNG     ; print header
 E5ED 3510                    PULS    X
 E5EF BDF512          HD1     JSR     PCRLF
 E5F2 BDF536                  JSR     PRINTX     ; print address
 E5F5 C610                    LDB     #16        ; byte counter
 E5F7 BDF5B3          HD2     JSR     OUT2HS     ; print a byte
 E5FA 5A                      DECB
 E5FB 2709                    BEQ     HD3        ; end of line ?
 E5FD C108                    CMPB    #8         ; half way ?
 E5FF 26F6                    BNE     HD2
 E601 BDF5B5                  JSR     OUTS       ; yes,print a space
 E604 20F1                    BRA     HD2
                      ; @@ BEGIN ASCII DUMP ADD
 E606 BDF5B5          HD3     JSR     OUTS       ; @@ print space
 E609 C6F0                    LDB     #-16       ; @@ prepare for 16 loops
 E60B A685            ASCLOOP LDA     B,X        ; @@ load byte
 E60D 8120                    CMPA    #$20       ; @@ printable ?
 E60F 2D04                    BLT     NOTPRT     ; @@ no
 E611 817F                    CMPA    #$7F       ; @@ printable ?
 E613 2D02                    BLT     HDCONT     ; @@ yes
 E615 862E            NOTPRT  LDA     #'.'       ; @@ if not printable print a dot
 E617 BDF16E          HDCONT  JSR     OUTCH      ; @@ now print
 E61A 5C                      INCB               ; @@ next byte
 E61B 26EE                    BNE     ASCLOOP    ; @@ 16 bytes printed ? no do again
                      ; @@ END ASCII DUMP ADD
 E61D 313F                    LEAY    -1,Y       ; end of page ?
 E61F 26CE                    BNE     HD1        ; no,do another line
 E621 BDF16C                  JSR     INCH       ; yes,input a char
 E624 810D                    CMPA    #$0D       ; if char == CR
 E626 27B6                    BEQ     HD4        ; do another page
 E628 812D                    CMPA    #'-'       ; if char == '-'
 E62A 10260AB1                LBNE    CONTRL
 E62E 3089FE00                LEAX    -512,X     ; do previous page
 E632 20AA                    BRA     HD4
                      ;*
                      ;* Poke memory.
 E634 0D506F6B65206D  POKMES  FCB     $0D,"Poke memory at ",4
 E63B 656D6F72792061
 E642 742004

 E645 8EE634          PM      LDX     #POKMES
 E648 BDF51E                  JSR     PDATA1
 E64B BDF55C                  JSR     BADDR      ; input addr
 E64E 1F12                    TFR     X,Y
 E650 8EE498                  LDX     #VALUES
 E653 BDF51E                  JSR     PDATA1
 E656 BDF567                  JSR     BYTE       ; input 'value'
 E659 A7A4                    STA     ,Y         ; store at addr
 E65B 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Keyboard to memory.
 E65E 0D4C6F6164206D  LOAKES  FCB     $0D,"Load memory with text from keyboard to ",4
 E665 656D6F72792077
 E66C 69746820746578
 E673 742066726F6D20
 E67A 6B6579626F6172
 E681 6420746F2004

 E687 8EE65E          LK      LDX     #LOAKES
 E68A BDF51E                  JSR     PDATA1
 E68D BDF55C                  JSR     BADDR      ; input addr
 E690 1F12                    TFR     X,Y
 E692 8EE498                  LDX     #VALUES
 E695 BDF51E                  JSR     PDATA1
 E698 BDF16C          LK1     JSR     INCH       ; input a character
 E69B A7A0                    STA     ,Y+        ; store it
 E69D 8104                    CMPA    #$04       ; was it EOT ?
 E69F 26F7                    BNE     LK1        ; no,input another
 E6A1 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Memory load and examine.
 E6A4 0D4D656D6F7279  MEMEXS   FCB    $0D,"Memory examine and modify from ",4
 E6AB 206578616D696E
 E6B2 6520616E64206D
 E6B9 6F646966792066
 E6C0 726F6D2004
 E6C5 0720204E6F2072  NORAM    FCB    7,"  No ram at that address!",4
 E6CC 616D2061742074
 E6D3 68617420616464
 E6DA 726573732104

 E6E0 8EE6A4          ME      LDX     #MEMEXS
 E6E3 BDF51E                  JSR     PDATA1
 E6E6 BDF55C                  JSR     BADDR      ; input addr
 E6E9 BDF512          ME1     JSR     PCRLF
 E6EC BDF536                  JSR     PRINTX     ; display addr
 E6EF BDF5B3                  JSR     OUT2HS     ; and content
 E6F2 BDF16C                  JSR     INCH       ; input a char
 E6F5 812D                    CMPA    #'-'       ; was it a '-' ?
 E6F7 2604                    BNE     ME2
 E6F9 301E                    LEAX    -2,X       ; yes,back 2 locations
 E6FB 20EC                    BRA     ME1
 E6FD 810D            ME2     CMPA    #$0D       ; was it CR ?
 E6FF 27E8                    BEQ     ME1        ; yes,display next
 E701 8120                    CMPA    #$20       ; was it a space ?
 E703 102609D8        MED     LBNE    CONTRL     ; no,abort
 E707 BDF567                  JSR     BYTE       ; yes,input byte
 E70A A71F                    STA     -1,X       ; overwrite old byte
 E70C A11F                    CMPA    -1,X       ; read it back
 E70E 27D9                    BEQ     ME1        ; OK,display it
 E710 8EE6C5                  LDX     #NORAM     ; cant read,send
 E713 BDF51E                  JSR     PDATA1     ; error message
 E716 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Print registers.
 E719 0D446973706C61  DISRES  FCB     $0D,"Display CPU registers.",4
 E720 79204350552072
 E727 65676973746572
 E72E 732E04
 E731 0A0D4343202041  RSTRNG  FCB     $0A,$0D,"CC  A  B DP    X    Y    U   PC    S",$0A,$0D,4
 E738 20204220445020
 E73F 20202058202020
 E746 20592020202055
 E74D 20202050432020
 E754 2020530A0D04

 E75A 8EE719          DR      LDX     #DISRES
 E75D BDF51E                  JSR     PDATA1
 E760 8EE731          DR1     LDX     #RSTRNG
 E763 BDF51E                  JSR     PDATA1     ; print header
 E766 1F41                    TFR     S,X
 E768 BDF5B3                  JSR     OUT2HS     ; print registers
 E76B BDF5B3                  JSR     OUT2HS
 E76E BDF5B3                  JSR     OUT2HS
 E771 BDF5B3                  JSR     OUT2HS
 E774 BDF5B1                  JSR     OUT4HS
 E777 BDF5B1                  JSR     OUT4HS
 E77A BDF5B1                  JSR     OUT4HS
 E77D BDF5B1                  JSR     OUT4HS
 E780 8EDF80                  LDX     #STACK     ; get Stack Pointer
 E783 BDF5B1                  JSR     OUT4HS     ; print it
 E786 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Shift blocks of memory.
 E789 0D536869667420  SHIMES  FCB     $0D,"Shift block of memory from ",4
 E790 626C6F636B206F
 E797 66206D656D6F72
 E79E 792066726F6D20
 E7A5 04
 E7A6 204C656E677468  LENGHS  FCB     " Length ",4
 E7AD 2004

 E7AF 8EE789          SM      LDX     #SHIMES
 E7B2 BDF51E                  JSR     PDATA1
 E7B5 BDF55C                  JSR     BADDR      ; get 'from' addr
 E7B8 3440                    PSHS    U
 E7BA 1F13                    TFR     X,U        ; store it in U
 E7BC 8EE473                  LDX     #TOS
 E7BF BDF51E                  JSR     PDATA1
 E7C2 BDF55C                  JSR     BADDR      ; get 'to' addr
 E7C5 1F12                    TFR     X,Y        ; store it in Y
 E7C7 8EE7A6                  LDX     #LENGHS
 E7CA BDF51E                  JSR     PDATA1
 E7CD BDF55C                  JSR     BADDR      ; get length of block
 E7D0 A6C0            SM1     LDA     ,U+        ; move a byte
 E7D2 A7A0                    STA     ,Y+
 E7D4 301F                    LEAX    -1,X       ; dec. length
 E7D6 26F8                    BNE     SM1        ; repeat 'till end
 E7D8 3540                    PULS    U
 E7DA 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Test memory.
 E7DD 0D54657374206D  TESMES  FCB     $0D,"Test memory from ",4
 E7E4 656D6F72792066
 E7EB 726F6D2004
 E7F0 070A0D4572726F  TMS1    FCB     7,$0A,$0D,"Error at location ",4
 E7F7 72206174206C6F
 E7FE 636174696F6E20
 E805 04
 E806 6368616E676564  TMS2    FCB     "changed to ",4
 E80D 20746F2004
 E812 2054657374696E  TMS3    FCB     " Testing now with ",4
 E819 67206E6F772077
 E820 6974682004

 E825 8EE7DD          TM      LDX     #TESMES
 E828 BDF51E                  JSR     PDATA1
 E82B BDF55C                  JSR     BADDR      ; get 'from'
 E82E 1F12                    TFR     X,Y        ; put in Y
 E830 8EE473                  LDX     #TOS
 E833 BDF51E                  JSR     PDATA1
 E836 BDF55C                  JSR     BADDR      ; get 'to'
 E839 BFDF92                  STX     XTEMP      ; store it
 E83C 5F                      CLRB
 E83D 8EE812                  LDX     #TMS3
 E840 BDF51E                  JSR     PDATA1
 E843 F7DF91          TM5     STB     TEMP       ; store 'with'
 E846 8EDF91                  LDX     #TEMP
 E849 BDF5A9                  JSR     OUT2H      ; display 'with'
 E84C 1F21                    TFR     Y,X
 E84E E7A4            TM1     STB     ,Y         ; write/read test
 E850 E1A4                    CMPB    ,Y
 E852 261A                    BNE     TM2        ; test fails,branch
 E854 3121            TM4     LEAY    1,Y        ; else,next location
 E856 10BCDF92                CMPY    XTEMP      ; all done ?
 E85A 26F2                    BNE     TM1
 E85C 5C                      INCB               ; yes,next 'with' byte
 E85D 270C                    BEQ     TM3        ; done 'em all.Exit
 E85F 8608                    LDA     #$08       ; else,update 'with'
 E861 BDF16E                  JSR     OUTCH      ; byte,return to
 E864 BDF16E                  JSR     OUTCH      ; first location
 E867 1F12                    TFR     X,Y        ; and continue
 E869 20D8                    BRA     TM5
 E86B 7EF0DF          TM3     JMP     CONTRL
 E86E 8EE7F0          TM2     LDX     #TMS1      ; error message
 E871 BDF51E                  JSR     PDATA1
 E874 10BFDF92                STY     XTEMP
 E878 8EDF92                  LDX     #XTEMP     ; (faulty location)
 E87B BDF5B1                  JSR     OUT4HS
 E87E BDF5B5                  JSR     OUTS
 E881 BDF5B5                  JSR     OUTS
 E884 F7DF91                  STB     TEMP       ; (test byte)
 E887 8EDF91                  LDX     #TEMP
 E88A BDF5B3                  JSR     OUT2HS
 E88D 8EE806                  LDX     #TMS2
 E890 BDF51E                  JSR     PDATA1
 E893 A6A4                    LDA     ,Y         ; (byte read back)
 E895 B7DF91                  STA     TEMP
 E898 8EDF91                  LDX     #TEMP
 E89B BDF5B3                  JSR     OUT2HS
 E89E 20CB                    BRA     TM3        ; exit
                      ;*
                      ;*
                      ;* Read floppy sector.
 E8A0 0D526561642066  REASES  FCB     $0D,"Read from sector on drive ",4
 E8A7 726F6D20736563
 E8AE 746F72206F6E20
 E8B5 64726976652004
 E8BC 20747261636B20  TRACS   FCB     " track ",4
 E8C3 04
 E8C4 20736563746F72  SECS    FCB     " sector ",4
 E8CB 2004
 E8CD 0D0A0746444320  ERR1    FCB     $0D,$0A,7,"FDC error code = ",4
 E8D4 6572726F722063
 E8DB 6F6465203D2004

 E8E2 8EE8A0          RS      LDX     #REASES
 E8E5 BDF51E                  JSR     PDATA1
 E8E8 BDF58C                  JSR     INHEX      ; get drive No
 E8EB B7DF8E                  STA     DRIVE
 E8EE 8EDF8B                  LDX     #(DRIVE-3)
 E8F1 BDF4B7                  JSR     DRV        ; get drive
 E8F4 8EE8BC                  LDX     #TRACS
 E8F7 BDF51E                  JSR     PDATA1
 E8FA BDF567                  JSR     BYTE       ; get track
 E8FD B7DF8F                  STA     TRACK
 E900 8EE8C4                  LDX     #SECS
 E903 BDF51E                  JSR     PDATA1
 E906 BDF567                  JSR     BYTE       ; get sector
 E909 B7DF90                  STA     SECTOR
 E90C 8EE473                  LDX     #TOS
 E90F BDF51E                  JSR     PDATA1
 E912 BDF55C                  JSR     BADDR      ; get load addr
 E915 B6DF8F                  LDA     TRACK
 E918 F6DF90                  LDB     SECTOR
 E91B BDF4A2                  JSR     READ       ; read it in
 E91E 102707BD                LBEQ    CONTRL     ; if no read error
 E922 8EE8CD                  LDX     #ERR1
 E925 BDF51E                  JSR     PDATA1     ; else,error message
 E928 F7DF91                  STB     TEMP       ; (status,masked)
 E92B 8EDF91                  LDX     #TEMP
 E92E BDF5B3                  JSR     OUT2HS     ; error No
 E931 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Write floppy sector
 E934 0D577269746520  WRIMES  FCB     $0D,"Write to sector on drive ",4
 E93B 746F2073656374
 E942 6F72206F6E2064
 E949 726976652004
 E94F 2066726F6D2004  FROMS   FCB     " from ",4

 E956 8EE934          WS      LDX     #WRIMES
 E959 BDF51E                  JSR     PDATA1
 E95C BDF58C                  JSR     INHEX      ; get drive No
 E95F B7DF8E                  STA     DRIVE
 E962 8EDF8B                  LDX     #(DRIVE-3)
 E965 BDF4B7                  JSR     DRV        ; get drive
 E968 8EE8BC                  LDX     #TRACS
 E96B BDF51E                  JSR     PDATA1
 E96E BDF567                  JSR     BYTE       ; get track
 E971 B7DF8F                  STA     TRACK
 E974 8EE8C4                  LDX     #SECS
 E977 BDF51E                  JSR     PDATA1
 E97A BDF567                  JSR     BYTE       ; get sector
 E97D B7DF90                  STA     SECTOR
 E980 8EE94F                  LDX     #FROMS
 E983 BDF51E                  JSR     PDATA1
 E986 BDF55C                  JSR     BADDR      ; get data addr
 E989 B6DF8F                  LDA     TRACK
 E98C F6DF90                  LDB     SECTOR
 E98F BDF4A6                  JSR     WRITE      ; write sector
 E992 10270749                LBEQ    CONTRL     ; if no write error
 E996 8EE8CD                  LDX     #ERR1
 E999 BDF51E                  JSR     PDATA1     ; else,error message
 E99C F7DF91                  STB     TEMP
 E99F 8EDF91                  LDX     #TEMP
 E9A2 BDF5B3                  JSR     OUT2HS
 E9A5 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Format disc to FLEX standard.
 E9A8 0D466F726D6174  DISFOS  FCB     $0D,"Format disc to flex standard on drive ",4
 E9AF 20646973632074
 E9B6 6F20666C657820
 E9BD 7374616E646172
 E9C4 64206F6E206472
 E9CB 6976652004
 E9D0 20736372617463  SURES   FCB     " scratch disc in drive? ",4
 E9D7 68206469736320
 E9DE 696E2064726976
 E9E5 653F2004

 E9E9 8EE9A8          DF      LDX     #DISFOS
 E9EC BDF51E                  JSR     PDATA1
 E9EF BDF58C                  JSR     INHEX      ; get drive No
 E9F2 B7DF8E                  STA     DRIVE
 E9F5 8EDF8B                  LDX     #DRIVE-3
 E9F8 BDF4AE                  JSR     RST        ; restore to 00
 E9FB 7FDFF4                  CLR     DEN        ; set single density
 E9FE 8EE9D0                  LDX     #SURES     ; prompt for scratch
 EA01 BDF51E                  JSR     PDATA1     ; disc in drive
 EA04 BDF16C                  JSR     INCH       ; get reply
 EA07 8159                    CMPA    #'Y'       ; if not 'Y'
 EA09 102606D2                LBNE    CONTRL     ; then abort
 EA0D 86FF            FMT     LDA     #$FF       ; else,initialise
 EA0F B7DF8F                  STA     TRACK      ; (01-1)
 EA12 108E0002                LDY     #$0002     ; (track/sector)
 EA16 4F              FMT1    CLRA
 EA17 B7DF90                  STA     SECTOR     ; (01-1)
 EA1A 7CDF8F                  INC     TRACK
 EA1D B6DF8F                  LDA     TRACK
 EA20 C601                    LDB     #1
 EA22 BDF50B                  JSR     SEEK
                      ;* This is written to all tracks
 EA25 4F                      CLRA
 EA26 8E0190                  LDX     #0400      ; starting this addr
 EA29 C606                    LDB     #6
 EA2B 1700FA                  LBSR    WABT       ; 6 bytes---00
 EA2E 86FC                    LDA     #$FC
 EA30 A780                    STA     ,X+        ; 1 bytes---FC
 EA32 CCFF07                  LDD     #$FF07
 EA35 1700F0                  LBSR    WABT       ; 7 bytes---FF
                      ;* This written to all sectors
 EA38 4F              FMT2    CLRA
 EA39 7CDF90                  INC     SECTOR
 EA3C C606                    LDB     #6
 EA3E 1700E7                  LBSR    WABT       ; 6 bytes---00
 EA41 86FE                    LDA     #$FE
 EA43 A780                    STA     ,X+        ; 1 bytes---FE
 EA45 B6DF8F                  LDA     TRACK
 EA48 A780                    STA     ,X+        ; 1 bytes---[TRACK]
 EA4A 4F                      CLRA
 EA4B A780                    STA     ,X+        ; 1 bytes---00
 EA4D B6DF90                  LDA     SECTOR
 EA50 A780                    STA     ,X+        ; 1 bytes---[SECTOR]
 EA52 8601                    LDA     #1
 EA54 A780                    STA     ,X+        ; 1 bytes---01
 EA56 86F7                    LDA     #$F7
 EA58 A780                    STA     ,X+        ; 1 bytes---F7
 EA5A CCFF0B                  LDD     #$FF0B
 EA5D 1700C8                  LBSR    WABT       ; 11 bytes---FF
 EA60 4F                      CLRA
 EA61 C606                    LDB     #6
 EA63 1700C2                  LBSR    WABT       ; 6 bytes---00
 EA66 86FB                    LDA     #$FB
 EA68 A780                    STA     ,X+        ; 1 bytes---FB
                      ;* Enter track/sector link, clear data bytes,
                      ;* update track/sector link.
 EA6A 1F20                    TFR     Y,D        ; get T/S link addr
 EA6C ED81                    STD     ,X++       ; enter it
 EA6E 5C                      INCB
 EA6F C10B                    CMPB    #11        ; all sectors done ?
 EA71 260A                    BNE     FMT3       ; no,continue
 EA73 4C                      INCA               ; yes,update T/S
 EA74 C601                    LDB     #1         ; link address
 EA76 8128                    CMPA    #40        ; all tracks done ?
 EA78 2603                    BNE     FMT3       ; no,continue
 EA7A CC0000                  LDD     #0         ; yes,clear T/S link
 EA7D 1F02            FMT3    TFR     D,Y        ; save updated link
 EA7F 4F                      CLRA               ; clear data bytes
 EA80 C6FE                    LDB     #254       ; 254 bytes---00
 EA82 1700A3                  LBSR    WABT
 EA85 86F7                    LDA     #$F7
 EA87 A780                    STA     ,X+        ; 1 bytes---F7
 EA89 CCFF0E                  LDD     #$FF0E
 EA8C 170099                  LBSR    WABT       ; 14 bytes---FF
 EA8F B6DF90                  LDA     SECTOR
 EA92 810A                    CMPA    #10        ; last sector ?
 EA94 26A2                    BNE     FMT2       ; no,do next
 EA96 86FF                    LDA     #$FF
 EA98 5F                      CLRB
 EA99 17008C                  LBSR    WABT       ; 256 bytes---FF
                      ;* Write a track to disc
 EA9C 8E0190                  LDX     #0400
 EA9F 86F4                    LDA     #$F4       ; write track cmd.
 EAA1 17077E                  LBSR    FCMD
 EAA4 B6FF10          FMT4    LDA     COMREG     ; get status
 EAA7 8502                    BITA    #2         ; D-reg empty ?
 EAA9 2705                    BEQ     FMT5
 EAAB A680                    LDA     ,X+        ; yes,load it
 EAAD B7FF13                  STA     DATREG
 EAB0 B6FF10          FMT5    LDA     COMREG
 EAB3 8501                    BITA    #1         ; busy ?
 EAB5 26ED                    BNE     FMT4       ; yes,wait
 EAB7 B6DF8F                  LDA     TRACK
 EABA 8127                    CMPA    #39        ; last track ?
 EABC 1026FF56                LBNE    FMT1       ; no,do next
                      ;* Remove link addr.from final directory sector
 EAC0 8EDF8B                  LDX     #DRIVE-3
 EAC3 BDF4AE                  JSR     RST
 EAC6 8EDE80                  LDX     #BUFFER    ; read T/S 00/0A
 EAC9 4F                      CLRA               ; into buffer
 EACA C60A                    LDB     #10        ; zero the link addr
 EACC BDF4A2                  JSR     READ       ; (no more directory sectors)
 EACF 8EDE80                  LDX     #BUFFER
 EAD2 6F84                    CLR     ,X
 EAD4 6F01                    CLR     1,X
 EAD6 4F                      CLRA
 EAD7 C60A                    LDB     #10        ; and write it
 EAD9 BDF4A6                  JSR     WRITE      ; back to disc
                      ;* Enter data to Sys.Information sector
 EADC 8EDE80                  LDX     #BUFFER
 EADF 4F                      CLRA
 EAE0 C603                    LDB     #3
 EAE2 BDF4A2                  JSR     READ       ; read T/S 00/03
 EAE5 8EDE80                  LDX     #BUFFER
 EAE8 6F84                    CLR     ,X         ; clear link addr
 EAEA 6F01                    CLR     1,X
 EAEC CC5343                  LDD     #$5343     ; enter name of disc
 EAEF ED8810                  STD     16,X
 EAF2 CC5241                  LDD     #$5241     ; (SCRATCH!)
 EAF5 ED8812                  STD     18,X
 EAF8 CC5443                  LDD     #$5443
 EAFB ED8814                  STD     20,X
 EAFE CC4821                  LDD     #$4821
 EB01 ED8816                  STD     22,X
 EB04 CC0001                  LDD     #1         ; enter Vol. No
 EB07 ED881B                  STD     27,X
 EB0A CC0101                  LDD     #$0101     ; enter start of
 EB0D ED881D                  STD     29,X       ; free chain
 EB10 CC270A                  LDD     #$270A     ; enter end of
 EB13 ED881F                  STD     31,X       ; free chain and
 EB16 ED8826                  STD     38,X       ; highest sector adr
 EB19 CC0186                  LDD     #$0186     ; enter length of
 EB1C ED8821                  STD     33,X       ; free chain. (ie.
 EB1F 4F                      CLRA               ; sectors left)
 EB20 C603                    LDB     #3
 EB22 BDF4A6                  JSR     WRITE      ; write it back
 EB25 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* This subroutine stores ACCA in [B] locations
                      ;* starting at location [X]
 EB28 3404            WABT    PSHS    B
 EB2A A780            WABT1   STA     ,X+
 EB2C 5A                      DECB
 EB2D 26FB                    BNE     WABT1
 EB2F 3584                    PULS    B,PC
                      ;*
                      ;* Random read test on drive.
 EB31 0D52616E646F6D  TDMES   FCB     $0D,"Random sector read on drive ",4
 EB38 20736563746F72
 EB3F 2072656164206F
 EB46 6E206472697665
 EB4D 2004
 EB4F 48697420616E79  TDMES1  FCB     "Hit any key to stop.",4
 EB56 206B657920746F
 EB5D 2073746F702E04
 EB64 61742074726163  ERR2    FCB     "at track/sector ",4
 EB6B 6B2F736563746F
 EB72 722004

 EB75 8EEB31          TD      LDX     #TDMES
 EB78 BDF51E                  JSR     PDATA1
 EB7B BDF58C                  JSR     INHEX      ; get drive No
 EB7E B7DF8E                  STA     DRIVE
 EB81 8EEB4F                  LDX     #TDMES1
 EB84 BDF525                  JSR     PSTRNG
 EB87 8EDF8B                  LDX     #(DRIVE-3)
 EB8A BDF4AE                  JSR     RST
 EB8D BDF5BA          TDLOOP  JSR     RANDOM     ; get a random No
 EB90 840F                    ANDA    #$0F       ; 15 max
 EB92 8B01                    ADDA    #1         ; >0
 EB94 810A                    CMPA    #10        ; >10 ?
 EB96 2EF5                    BGT     TDLOOP     ; yes,get another
 EB98 B7DF90                  STA     SECTOR     ; else,store it
 EB9B BDF5BA          TDLP2   JSR     RANDOM     ; get a random No
 EB9E 843F                    ANDA    #$3F       ; 63 max
 EBA0 8127                    CMPA    #39        ; >39 ?
 EBA2 2EF7                    BGT     TDLP2      ; yes,get another
 EBA4 B7DF8F                  STA     TRACK      ; else,set random
 EBA7 F6DF90                  LDB     SECTOR     ; track and sector
 EBAA 8EDE80                  LDX     #BUFFER
 EBAD BDF4A2                  JSR     READ       ; read into buffer
 EBB0 260E                    BNE     TDLP9      ; read error if <> 0
 EBB2 BDF131                  JSR     STATUS     ; key pressed ?
 EBB5 27D6                    BEQ     TDLOOP     ; no,continue
 EBB7 8EDF8B                  LDX     #(DRIVE-3) ; yes,
 EBBA BDF4AE                  JSR     RST        ; restore to 00
 EBBD 7EF0DF                  JMP     CONTRL     ; and abort
 EBC0 8EE8CD          TDLP9   LDX     #ERR1      ; report ----
 EBC3 BDF51E                  JSR     PDATA1
 EBC6 F7DF91                  STB     TEMP
 EBC9 8EDF91                  LDX     #TEMP
 EBCC BDF5B3                  JSR     OUT2HS     ; error No.'x', at
 EBCF 8EEB64                  LDX     #ERR2
 EBD2 BDF51E                  JSR     PDATA1
 EBD5 8EDF8F                  LDX     #TRACK
 EBD8 BDF5B1                  JSR     OUT4HS     ; 'track/sector'
 EBDB 20B0                    BRA     TDLOOP     ; continue
                      ;*
                      ;* Test drive stepping.
 EBDD 0D546573742073  TSMESS  FCB     $0D,"Test stepping on drive ",4
 EBE4 74657070696E67
 EBEB 206F6E20647269
 EBF2 76652004

 EBF6 8EEBDD          TS      LDX     #TSMESS
 EBF9 BDF51E                  JSR     PDATA1
 EBFC BDF58C                  JSR     INHEX      ; get drive No
 EBFF B7DF8E                  STA     DRIVE
 EC02 8EDF8B                  LDX     #(DRIVE-3)
 EC05 BDF4B7                  JSR     DRV        ; select drive
 EC08 8628            TSLOOP  LDA     #40        ; track 40,sector 1
 EC0A C601                    LDB     #1
 EC0C BDF50B                  JSR     SEEK
 EC0F BDF4AE                  JSR     RST        ; restore to 00
 EC12 BDF131                  JSR     STATUS     ; key pressed ?
 EC15 102604C6                LBNE    CONTRL     ; yes,abort
 EC19 20ED                    BRA     TSLOOP     ; no,do it again
                      ;*
                      ;*
                      ;********************************************
                      ;* Extra system dependant commands go here. *
                      ;********************************************
                      ;* LIB COMMANDS
                      ;* Boot Flex from floppy 0 regardless of allocation
 EC1B 7FDF9D          BF      CLR     DDSTAB     ; set Drv.0=floppy 0
 EC1E 16F707                  LBRA    BO         ; jump to loader
 EC21 7EF0DF                  JMP     CONTRL     ; this appears to be redundant ?
                      ;*
                      ;* Display RTC non volatile data
 EC24 0D              DCMES   FCB     $0D
 EC25 446973706C6179          FCC     "Display RTC contents."
 EC2C 2052544320636F
 EC33 6E74656E74732E
 EC3A 04                      FCB     $04

 EC3B 8EEC24          DC      LDX     #DCMES     ; print header
 EC3E BDF51E                  JSR     PDATA1
 EC41 BDF512                  JSR     PCRLF
 EC44 5F                      CLRB               ; point to 1st byte
 EC45 8E000E                  LDX     #$000E
 EC48 8D2B                    BSR     PBLIN      ; time, date & regs (14 bytes)
 EC4A 8E0001                  LDX     #$0001
 EC4D 8D26                    BSR     PBLIN      ; configuration SW (1byte)
 EC4F 8E0001                  LDX     #$0001
 EC52 8D21                    BSR     PBLIN      ; baudrates (1 byte)
 EC54 8E0004                  LDX     #$0004
 EC57 8D1C                    BSR     PBLIN      ; disc allocations (4 bytes)
 EC59 8E000B                  LDX     #$000B
 EC5C 8D17                    BSR     PBLIN      ; ttyset (11 bytes)
 EC5E 8E0002                  LDX     #$0002
 EC61 8D12                    BSR     PBLIN      ; asn (2 bytes)
 EC63 8E0008                  LDX     #$0008
 EC66 8D0D                    BSR     PBLIN      ; GDC defaults (8 bytes)
 EC68 8E0007                  LDX     #$0007
 EC6B 8D08                    BSR     PBLIN      ; reserved (7 bytes)
 EC6D 8E0010                  LDX     #$0010
 EC70 8D03                    BSR     PBLIN      ; not used (16 bytes available)
 EC72 7EF0DF                  JMP     CONTRL
                      ;*
                      ;* Prints a line of bytes
 EC75 BDF5EA          PBLIN   JSR     GETRTC     ; get byte
 EC78 5C                      INCB               ; point to next
 EC79 B7DF91                  STA     TEMP
 EC7C 3410                    PSHS    X
 EC7E 8EDF91                  LDX     #TEMP      ; output bytes
 EC81 BDF5B3                  JSR     OUT2HS
 EC84 3510                    PULS    X
 EC86 301F                    LEAX    -$01,X
 EC88 26EB                    BNE     PBLIN      ; until line finished
 EC8A BDF512                  JSR     PCRLF
 EC8D 39                      RTS
                      ;*
                      ;* Modify RTC non volatile data
 EC8E 0D              MCMES   FCB     $0D
 EC8F 52544320657861          FCC     "RTC examine and alter"
 EC96 6D696E6520616E
 EC9D 6420616C746572
 ECA4 2066726F6D20            FCC     " from "
 ECAA 04                      FCB     $04

 ECAB 8EEC8E          MC      LDX     #MCMES
 ECAE BDF51E                  JSR     PDATA1     ; print header
 ECB1 BDF567                  JSR     BYTE       ; input offset
 ECB4 1F89                    TFR     A,B
 ECB6 C43F            MC1     ANDB    #$3F
 ECB8 BDF512                  JSR     PCRLF
 ECBB F7DF91                  STB     TEMP
 ECBE 8EDF91                  LDX     #TEMP
 ECC1 BDF5B3                  JSR     OUT2HS     ; print offset
 ECC4 BDF5EA                  JSR     GETRTC     ; get that byte
 ECC7 B7DF91                  STA     TEMP
 ECCA 8EDF91                  LDX     #TEMP
 ECCD BDF5A9                  JSR     OUT2H      ; and print it
 ECD0 BDF16C                  JSR     INCH       ; input a char
 ECD3 8120                    CMPA    #$20       ; was it a space ?
 ECD5 2609                    BNE     MC2
 ECD7 BDF567                  JSR     BYTE       ; yes,input a byte
 ECDA BDF608                  JSR     PUTRTC     ; put in RTC
 ECDD 5C                      INCB               ; point to next
 ECDE 20D6                    BRA     MC1        ; and jump to it
 ECE0 810D            MC2     CMPA    #$0D       ; was it <cr> ?
 ECE2 2603                    BNE     MC3
 ECE4 5C                      INCB               ; yes,point to next
 ECE5 20CF                    BRA     MC1
 ECE7 812D            MC3     CMPA    #$2D       ; was it a '-' ?
 ECE9 102603F2                LBNE    CONTRL     ; no,exit
 ECED 5A                      DECB               ; yes,backpeddle 1
 ECEE 20C6                    BRA     MC1
                      ;*
                      ;* Find byte string [There is a BUG in this routine ?]
                      ;*
 ECF0 0D              FIMES   FCB     $0D
 ECF1 46696E64206279          FCC     "Find byte string from"
 ECF8 74652073747269
 ECFF 6E672066726F6D
 ED06 20                      FCC     " "
 ED07 04                      FCB     $04
 ED08 0D0A            EBSMS   FCB     $0D,$0A
 ED0A 656E7465722062          FCC     "enter byte string  "
 ED11 79746520737472
 ED18 696E672020
 ED1D 04                      FCB     $04
                      ;* Get start & end addresses and load the string templet
 ED1E 8EECF0          FI      LDX     #FIMES
 ED21 BDF51E                  JSR     PDATA1
 ED24 BDF55C                  JSR     BADDR      ; input 'from'
 ED27 BFDF94                  STX     YTEMP      ; store it
 ED2A 8EE473                  LDX     #TOS
 ED2D BDF51E                  JSR     PDATA1
 ED30 BDF55C                  JSR     BADDR      ; input 'to'
 ED33 BFDF96                  STX     TTO        ; store it
 ED36 8EED08                  LDX     #EBSMS
 ED39 BDF51E                  JSR     PDATA1
 ED3C 8EDE80                  LDX     #BUFFER
 ED3F 5F                      CLRB               ; clr. count
 ED40 BDF567          FI1     JSR     BYTE       ; input a byte
 ED43 A780                    STA     ,X+        ; put in buffer
 ED45 5C                      INCB               ; inc. count
 ED46 BDF16C                  JSR     INCH       ; input a char
 ED49 8120                    CMPA    #$20       ; was it a space ?
 ED4B 27F3                    BEQ     FI1        ; yes,get next byte
                      ;* Search for a match with the templet
 ED4D F7DF91                  STB     TEMP       ; length of templet
 ED50 BEDF94                  LDX     YTEMP      ; point to start adr
 ED53 108EDE80                LDY     #BUFFER    ; & start of templet
 ED57 A680            FI2     LDA     ,X+        ; compare charater
 ED59 A1A0                    CMPA    ,Y+
 ED5B 2608                    BNE     FI3        ; no match, branch
 ED5D 5A                      DECB               ; end of string ?
 ED5E 26F7                    BNE     FI2        ; no, try next char
 ED60 BDF512                  JSR     PCRLF      ; yes,do CRLF
 ED63 8D11                    BSR     FI5        ; print out result
 ED65 F6DF91          FI3     LDB     TEMP       ; reset count
 ED68 108EDE80                LDY     #BUFFER    ; point to 1st char
 ED6C BCDF96                  CMPX    TTO        ; end of search block ?
 ED6F 2702                    BEQ     FI4        ; yes,exit
                      ;* BUG here. Should LEAX -1,X first...
 ED71 20E4                    BRA     FI2        ; no,continue search
 ED73 7EF0DF          FI4     JMP     CONTRL
                      ;* Print results (if any)
 ED76 3436            FI5     PSHS    Y,X,D
 ED78 B6DF91                  LDA     TEMP       ; get length of string
 ED7B 40                      NEGA
 ED7C 3086                    LEAX    A,X        ; sub.from current adr
 ED7E 1F12                    TFR     X,Y        ; copy to Y
 ED80 313A                    LEAY    -$06,Y     ; Y points to string-6
 ED82 BFDF92                  STX     XTEMP
 ED85 8EDF92                  LDX     #XTEMP     ; get addr.of string
 ED88 BDF5B1                  JSR     OUT4HS     ; print it
 ED8B 1F21                    TFR     Y,X        ; point to string-6
 ED8D C610                    LDB     #$10       ; print out 16 bytes
 ED8F A6A0            FI6     LDA     ,Y+
 ED91 B7DF92                  STA     XTEMP
 ED94 8EDF92                  LDX     #XTEMP
 ED97 BDF5B3                  JSR     OUT2HS
 ED9A 5A                      DECB
 ED9B 26F2                    BNE     FI6
 ED9D BDF5B5                  JSR     OUTS       ; followed by 2 spaces
 EDA0 BDF5B5                  JSR     OUTS
 EDA3 3130                    LEAY    -$10,Y     ; back to string-6
 EDA5 C610                    LDB     #$10       ; now print ascii
 EDA7 A6A0            FI7     LDA     ,Y+
 EDA9 8120                    CMPA    #$20       ; is it printable ?
 EDAB 2C02                    BGE     FI8        ; yes,print it
 EDAD 862E                    LDA     #$2E       ; no,substitute dot
 EDAF BDF16E          FI8     JSR     OUTCH
 EDB2 5A                      DECB
 EDB3 26F2                    BNE     FI7
 EDB5 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Set baud Rate
                      ;*
 EDB7 0D              SBMES   FCB     $0D
 EDB8 53657420626175          FCC     "Set baud rate for acia "
 EDBF 64207261746520
 EDC6 666F7220616369
 EDCD 6120
 EDCF 04                      FCB     $04
 EDD0 20626175642072  SBRMS   FCC     " baud rate = "
 EDD7 617465203D20
 EDDD 04                      FCB     $04
 EDDE 20426175642072  EBRNK   FCC     " Baud rate not known."
 EDE5 617465206E6F74
 EDEC 206B6E6F776E2E
 EDF3 04                      FCB     $04

 EDF4 8EEDB7          SB      LDX     #SBMES
 EDF7 BDF51E                  JSR     PDATA1
 EDFA BDF58C                  JSR     INHEX      ; get acia No
 EDFD 8401                    ANDA    #$01       ; NB.if acia2,A=0
 EDFF B7DF91                  STA     TEMP       ; store it
 EE02 8EEDD0                  LDX     #SBRMS     ; ask for baud rate
 EE05 BDF51E                  JSR     PDATA1
 EE08 BDF16C                  JSR     INCH       ; input first 2 digits
 EE0B 1F89                    TFR     A,B        ; (ascii/decimal),of
 EE0D BDF16C                  JSR     INCH       ; reqd.baud rate
 EE10 1E89                    EXG     A,B        ; put them in order
 EE12 1E02                    EXG     D,Y        ; and store in Y
 EE14 8EEE76                  LDX     #TBAUD     ; use look-up table
 EE17 10AC84          SB1     CMPY    ,X         ; found it ?
 EE1A 2710                    BEQ     SB2
 EE1C 3006                    LEAX    $06,X      ; no,try next
 EE1E 8CEED0                  CMPX    #EBAUD
 EE21 26F4                    BNE     SB1        ; all tried ?
 EE23 8EEDDE                  LDX     #EBRNK     ; yes,error exit
 EE26 BDF51E                  JSR     PDATA1
 EE29 7EF0DF                  JMP     CONTRL
 EE2C A602            SB2     LDA     $02,X      ; print out last 3 digits
 EE2E BDF16E                  JSR     OUTCH      ; of baud rate
 EE31 A603                    LDA     $03,X
 EE33 BDF16E                  JSR     OUTCH
 EE36 A604                    LDA     $04,X
 EE38 BDF16E                  JSR     OUTCH
 EE3B A605                    LDA     $05,X      ; pick-up RTC code and set baud rate
 EE3D 8EFF0C                  LDX     #BAUD      ; select register for
 EE40 F6DF91                  LDB     TEMP       ; nominated acia
 EE43 F7DF92                  STB     XTEMP
 EE46 3A                      ABX
 EE47 A784                    STA     ,X         ; load code
 EE49 B7DF91                  STA     TEMP       ; save code
 EE4C C60F                    LDB     #$0F       ; get existing RTC
 EE4E BDF5EA                  JSR     GETRTC
 EE51 7DDF92                  TST     XTEMP      ; which acia ?
 EE54 2607                    BNE     SB3        ; acia1,branch
 EE56 84F0                    ANDA    #$F0       ; erase acia2 code
 EE58 BBDF91                  ADDA    TEMP       ; subs. new code
 EE5B 2011                    BRA     SB4        ; go put in clock
 EE5D F6DF91          SB3     LDB     TEMP       ; was acia1. get code
 EE60 58                      ASLB               ; shift into high nibble
 EE61 58                      ASLB
 EE62 58                      ASLB
 EE63 58                      ASLB
 EE64 C4F0                    ANDB    #$F0
 EE66 840F                    ANDA    #$0F       ; erase acia1 code
 EE68 F7DF91                  STB     TEMP
 EE6B BBDF91                  ADDA    TEMP       ; subs. new code
 EE6E C60F            SB4     LDB     #$0F       ; store in RTC
 EE70 BDF608                  JSR     PUTRTC
 EE73 7EF0DF                  JMP     CONTRL
                      * Look-up table
 EE76 3530202020      TBAUD   FCC     "50   "
 EE7B 00                      FCB     $00
 EE7C 3735202020              FCC     "75   "
 EE81 01                      FCB     $01
 EE82 3131302020              FCC     "110  "
 EE87 02                      FCB     $02
 EE88 3133352020              FCC     "135  "
 EE8D 03                      FCB     $03
 EE8E 3135302020              FCC     "150  "
 EE93 04                      FCB     $04
 EE94 3330302020              FCC     "300  "
 EE99 06                      FCB     $06
 EE9A 3630302020              FCC     "600  "
 EE9F 07                      FCB     $07
 EEA0 3132303020              FCC     "1200 "
 EEA5 08                      FCB     $08
 EEA6 3138303020              FCC     "1800 "
 EEAB 09                      FCB     $09
 EEAC 3234303020              FCC     "2400 "
 EEB1 0A                      FCB     $0A
 EEB2 3336303020              FCC     "3600 "
 EEB7 0B                      FCB     $0B
 EEB8 3438303020              FCC     "4800 "
 EEBD 0C                      FCB     $0C
 EEBE 3732303020              FCC     "7200 "
 EEC3 0D                      FCB     $0D
 EEC4 3936303020              FCC     "9600 "
 EEC9 0E                      FCB     $0E
 EECA 3139323030              FCC     "19200"
 EECF 0F                      FCB     $0F
                      ;*
                      ;* Seems to be not used...
                      ;*
 EED0 FF29FFAB0052    EBAUD   FCB     $FF,$29,$FF,$AB,$00,$52  ;EEFE: FF 29 FF AB 00 52 '.)...R'
 EED6 FFA90250FFAB            FCB     $FF,$A9,$02,$50,$FF,$AB  ;EF04: FF A9 02 50 FF AB '...P..'
 EEDC 0012FFAB0210            FCB     $00,$12,$FF,$AB,$02,$10  ;EF0A: 00 12 FF AB 02 10 '......'
 EEE2 FFAB0010FFAB            FCB     $FF,$AB,$00,$10,$FF,$AB  ;EF10: FF AB 00 10 FF AB '......'
 EEE8 0250FFAB0212            FCB     $02,$50,$FF,$AB,$02,$12  ;EF16: 02 50 FF AB 02 12 '.P....'
 EEEE FFAB0050FFA9            FCB     $FF,$AB,$00,$50,$FF,$A9  ;EF1C: FF AB 00 50 FF A9 '...P..'
 EEF4 0252FFAB0050            FCB     $02,$52,$FF,$AB,$00,$50  ;EF22: 02 52 FF AB 00 50 '.R...P'
 EEFA FFA90212FFAB            FCB     $FF,$A9,$02,$12,$FF,$AB  ;EF28: FF A9 02 12 FF AB '......'
 EF00 0250FFEB0010            FCB     $02,$50,$FF,$EB,$00,$10  ;EF2E: 02 50 FF EB 00 10 '.P....'
 EF06 FFAB0010FFAB            FCB     $FF,$AB,$00,$10,$FF,$AB  ;EF34: FF AB 00 10 FF AB '......'
 EF0C 0050FF0B0010            FCB     $00,$50,$FF,$0B,$00,$10  ;EF3A: 00 50 FF 0B 00 10 '.P....'
 EF12 0000FBFF0000            FCB     $00,$00,$FB,$FF,$00,$00  ;EF40: 00 00 FB FF 00 00 '......'
 EF18 FBFF0000FBFF            FCB     $FB,$FF,$00,$00,$FB,$FF  ;EF46: FB FF 00 00 FB FF '......'
 EF1E 0000FBFF0000            FCB     $00,$00,$FB,$FF,$00,$00  ;EF4C: 00 00 FB FF 00 00 '......'
 EF24 FBFF0000FFFF            FCB     $FB,$FF,$00,$00,$FF,$FF  ;EF52: FB FF 00 00 FF FF '......'
 EF2A 0000FBFF0000            FCB     $00,$00,$FB,$FF,$00,$00  ;EF58: 00 00 FB FF 00 00 '......'
 EF30 FFFF0000FBFF            FCB     $FF,$FF,$00,$00,$FB,$FF  ;EF5E: FF FF 00 00 FB FF '......'
 EF36 0000FFFF0000            FCB     $00,$00,$FF,$FF,$00,$00  ;EF64: 00 00 FF FF 00 00 '......'
 EF3C FBFF0000FBFF            FCB     $FB,$FF,$00,$00,$FB,$FF  ;EF6A: FB FF 00 00 FB FF '......'
 EF42 0000FFFF0000            FCB     $00,$00,$FF,$FF,$00,$00  ;EF70: 00 00 FF FF 00 00 '......'
 EF48 FBFF0000FFFF            FCB     $FB,$FF,$00,$00,$FF,$FF  ;EF76: FB FF 00 00 FF FF '......'
 EF4E 0800FFFFA9FF            FCB     $08,$00,$FF,$FF,$A9,$FF  ;EF7C: 08 00 FF FF A9 FF '......'
 EF54 1000A9FF5000            FCB     $10,$00,$A9,$FF,$50,$00  ;EF82: 10 00 A9 FF 50 00 '....P.'
 EF5A ABFF1000A9FD            FCB     $AB,$FF,$10,$00,$A9,$FD  ;EF88: AB FF 10 00 A9 FD '......'
 EF60 5000A9FF5000            FCB     $50,$00,$A9,$FF,$50,$00  ;EF8E: 50 00 A9 FF 50 00 'P...P.'
 EF66 A9FF5200A9FF            FCB     $A9,$FF,$52,$00,$A9,$FF  ;EF94: A9 FF 52 00 A9 FF '..R...'
 EF6C 5200A9FD5002            FCB     $52,$00,$A9,$FD,$50,$02  ;EF9A: 52 00 A9 FD 50 02 'R...P.'
 EF72 A9FF1200A9FD            FCB     $A9,$FF,$12,$00,$A9,$FD  ;EFA0: A9 FF 12 00 A9 FD '......'
 EF78 1002A9FF5000            FCB     $10,$02,$A9,$FF,$50,$00  ;EFA6: 10 02 A9 FF 50 00 '....P.'
 EF7E A9FD5002A1FF            FCB     $A9,$FD,$50,$02,$A1,$FF  ;EFAC: A9 FD 50 02 A1 FF '..P...'
 EF84 5200A9FD1202            FCB     $52,$00,$A9,$FD,$12,$02  ;EFB2: 52 00 A9 FD 12 02 'R.....'
 EF8A A9FF5200A9FD            FCB     $A9,$FF,$52,$00,$A9,$FD  ;EFB8: A9 FF 52 00 A9 FD '..R...'
 EF90 52020000FFFF            FCB     $52,$02,$00,$00,$FF,$FF  ;EFBE: 52 02 00 00 FF FF 'R.....'
 EF96 0000FFFB0000            FCB     $00,$00,$FF,$FB,$00,$00  ;EFC4: 00 00 FF FB 00 00 '......'
 EF9C FFFB0000FFFB            FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFCA: FF FB 00 00 FF FB '......'
 EFA2 0000FFFB0000            FCB     $00,$00,$FF,$FB,$00,$00  ;EFD0: 00 00 FF FB 00 00 '......'
 EFA8 FFFB0000FFFB            FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFD6: FF FB 00 00 FF FB '......'
 EFAE 0000FFFB0000            FCB     $00,$00,$FF,$FB,$00,$00  ;EFDC: 00 00 FF FB 00 00 '......'
 EFB4 FFFF0000FFFB            FCB     $FF,$FF,$00,$00,$FF,$FB  ;EFE2: FF FF 00 00 FF FB '......'
 EFBA 0000FFFB0000            FCB     $00,$00,$FF,$FB,$00,$00  ;EFE8: 00 00 FF FB 00 00 '......'
 EFC0 FFFB0000FFFB            FCB     $FF,$FB,$00,$00,$FF,$FB  ;EFEE: FF FB 00 00 FF FB '......'
 EFC6 0008FFFB0000            FCB     $00,$08,$FF,$FB,$00,$00  ;EFF4: 00 08 FF FB 00 00 '......'
 EFCC FFFF0038FFC9            FCB     $FF,$FF,$00,$38,$FF,$C9  ;EFFA: FF FF 00 38 FF C9 '...8..'
                      ;*
                      ;* Wait 1ms routine
                      ;* Input A = number of ms to wait
 EFD2 C6C8            WAIT1MS LDB     #200
 EFD4 5A              LOOPW   DECB
 EFD5 26FD                    BNE     LOOPW
 EFD7 4A                      DECA
 EFD8 26F8                    BNE     WAIT1MS
 EFDA 39                      RTS
                      ;*
                      ;*
                             ORG   PROM+$1000
                      ;*
                      ;*
                      ;********************************************
                      ;* Table of jump addresses for subroutines. *
                      ;* To use these subroutines use the         *
                      ;* indirect jump to subroutine thus:-       *
                      ;*        DELAY EQU $F014                   *
                      ;*        JSR [DELAY]                       *
                      ;********************************************
 F000 F08E                   FDB   RESET        ; Cold start.
 F002 F0DF                   FDB   CONTRL       ; Warm  start.
 F004 F153                   FDB   INCH1        ; Input char without an echo.
 F006 F16C                   FDB   INCH         ; Input char.
 F008 F131                   FDB   STATUS       ; Check for char.
 F00A F16E                   FDB   OUTCH        ; Output char.
 F00C F51E                   FDB   PDATA1       ; Print string terminated by hex(04).
 F00E F512                   FDB   PCRLF        ; Print a cr followed by a lf.
 F010 F525                   FDB   PSTRNG       ; PCRLF followed by PDATA1.
 F012 F130                   FDB   DUMMY        ; No init code.
 F014 F542                   FDB   DELAY        ; Delay for (XREG) m/S.
 F016 F55C                   FDB   BADDR        ; Get a four digit hex address into X.
 F018 F567                   FDB   BYTE         ; Get a two hex digit number into A.
 F01A F58C                   FDB   INHEX        ; Get a one digit hex char into A.
 F01C F5A9                   FDB   OUT2H        ; Output two hex chars pointed to by X.
 F01E F5B3                   FDB   OUT2HS       ; OUT2H plus a space.
 F020 F5B1                   FDB   OUT4HS       ; Output four hex chars etc.
 F022 F57D                   FDB   OUTHR        ; Output right hex digit in A.
 F024 F579                   FDB   OUTHL        ; Output left hex digit in A.
 F026 F5B5                   FDB   OUTS         ; Output a space.
 F028 F5BA                   FDB   RANDOM       ; Returns a random number in the range 0-255.
 F02A F52A                   FDB   PRINTA       ; Output the contents of A.
 F02C F536                   FDB   PRINTX       ; Output the contents of X.
 F02E F4A2                   FDB   READ         ; Read sector routine.
 F030 F4A6                   FDB   WRITE        ; Write sector routine.
 F032 F4AA                   FDB   VERIFY       ; Verify sector routine.
 F034 F4AE                   FDB   RST          ; Restore to track 00.
 F036 F4B7                   FDB   DRV          ; Drive select.
 F038 F4E7                   FDB   CHKRDY       ; Check for drive ready.
 F03A F4EB                   FDB   QUICK        ; Quick check for drive ready.
 F03C F4EF                   FDB   DINIT        ; Drive cold start.
 F03E F507                   FDB   WARM         ; Drive warm start.
 F040 F50B                   FDB   SEEK         ; Seek to track.
                      ;*************************************
                      ;* Extra FDB'S for system dependant  *
                      ;* subroutines fit here.             *
                      ;*************************************
                      ;* LIB FDB
 F042 F5DD                   FDB   GETTIM
 F044 F5FB                   FDB   PUTTIM
 F046 F5EA                   FDB   GETRTC
 F048 F608                   FDB   PUTRTC
 F04A F61D                   FDB   BEEP
 F04C F641                   FDB   GCOM
 F04E F653                   FDB   GPRM
 F050 F662                   FDB   GPRMI
 F052 F66D                   FDB   MASK
 F054 F67F                   FDB   SETPEN
 F056 F696                   FDB   SETPAT
 F058 F6A9                   FDB   FIGSF
 F05A F6CE                   FDB   FIGSG
 F05C F6F7                   FDB   SETPAR
 F05E F75B                   FDB   SETCRG
 F060 F7B2                   FDB   GETCRG
 F062 FA68                   FDB   SETCRT
 F064 FA85                   FDB   GETCRT
 F066 F7FC                   FDB   OFF
 F068 F808                   FDB   ON
 F06A F814                   FDB   GRAPH
 F06C FAA4                   FDB   TEXT
 F06E F82F                   FDB   MODE
 F070 F846                   FDB   ZOOM
 F072 F85D                   FDB   FILL
 F074 F89E                   FDB   CLEARX
 F076 F87C                   FDB   CLEAR
 F078 FAC2                   FDB   CLEART
 F07A F8D3                   FDB   GDCINI
 F07C FB1C                   FDB   VIDCH
 F07E F18D                   FDB   INKEY
 F080 F91F                   FDB   POINT
 F082 F92B                   FDB   LINE
 F084 F9AB                   FDB   RECT
 F086 F9D8                   FDB   CIRCLE
 F088 FA29                   FDB   ARC
 F08A FAF1                   FDB   CLINK
 F08C F749                   FDB   VSYNC
                      ;*
                      ;**************************************
                      ;* Start of monitor  Entered on reset *
                      ;**************************************
                      ;*
 F08E B7FFDD          RESET  STA   $FFDD         ; Set up SAM for 64k dynamic ram.
 F091 B7FFDF                 STA   $FFDF         ; Set up SAM for map type 1.
                      ;*
 F094 B6DF9C                 LDA   WARMS
 F097 81AA                   CMPA  #$AA          ; Test for power down.
 F099 2718                   BEQ   U1
                      ;*
 F09B 4F                     CLRA
 F09C 8EDF80                 LDX   #SCRAT
 F09F A780            L1     STA   ,X+           ; Clear out scratch storage.
 F0A1 8CE000                 CMPX   #(RAM+512)
 F0A4 26F9                   BNE   L1
 F0A6 86AA                   LDA   #$AA
 F0A8 B7DF9C                 STA   WARMS
                      ;*
 F0AB 10CEDE6F               LDS   #SSTACK       ; Set initial stack pointer.
 F0AF 10FFDF80               STS   STACK         ; Same for user stack location.
                      ;*
 F0B3 108EF111        U1     LDY   #UNEXP
 F0B7 8EDF82                 LDX   #NMIV
 F0BA 10AF81          U1L    STY   ,X++
 F0BD 8CDF8C                 CMPX  #NMIV+10
 F0C0 26F8                   BNE   U1L
                      ;*
                      ;***********************************
                      ;* System dependant init code goes *
                      ;* here. It should set the initial *
                      ;* input and output ports then     *
                      ;* check for auto boot.            *
                      ;***********************************
                      ;* LIB MINIT1
                      ;*
 F0C2 864F                   LDA   #$4F
 F0C4 B7FF02                 STA   SYSREG        ; set DDRA
 F0C7 863C                   LDA   #$3C          ; Hi-nib=in
 F0C9 B7FF03                 STA   SYSREG+1      ; Lo-nib=out
 F0CC 8634                   LDA   #$34
 F0CE B7FF01                 STA   PIA1+1        ; setup keyboard port
 F0D1 8606                   LDA   #$06          ; set Drv 0,SD,and
 F0D3 B7FF02                 STA   SYSREG        ; Rom at $E000
 F0D6 7EE0EB                 JMP   MINIT1        ; do rest of setup
                      ;* (jump back here)
 F0D9 8EE000          MINITR LDX   #HDR          ; Print header after reset.
 F0DC BDF51E                 JSR   PDATA1
                      ;* Action control (Warm start entry)
 F0DF B6FF02          CONTRL LDA   SYSREG
 F0E2 8A04                   ORA   #4            ; Map in bottom 4k of eprom.
 F0E4 B7FF02                 STA   SYSREG
 F0E7 8EE027                 LDX   #PROMPT
 F0EA BDF51E                 JSR   PDATA1
 F0ED 8D7D                   BSR   INCH          ; Get two byte command into Y.
 F0EF 1F89                   TFR   A,B
 F0F1 8D79                   BSR   INCH
 F0F3 1E89                   EXG   A,B
 F0F5 1F02                   TFR   D,Y
 F0F7 8EE1FF          PARSE  LDX   #COMTAB       ; Point to start of command table.
 F0FA 10AC81          NEXT   CMPY  ,X++          ; Look for match.
 F0FD 2602                   BNE   NOPE          ; No match.
 F0FF 6E94                   JMP   [,X]          ; Found it, so jump to routine.
 F101 3002            NOPE   LEAX  2,X           ; If no match then jump over address.
 F103 A684                   LDA   ,X            ; Check for end of table.
 F105 81FF                   CMPA  #$FF
 F107 26F1                   BNE   NEXT          ; If not the end then try next entry.
 F109 8EE02C          WHAT   LDX   #NOTTHS       ; No match so print message.
 F10C BDF51E                 JSR   PDATA1
 F10F 20CE                   BRA   CONTRL
                      *
 F111 8EE040          UNEXP  LDX   #UNMESS       ; Unexpected interrupt ... Don't Panic!
 F114 BDF525                 JSR   PSTRNG
 F117 1A50                   ORCC  #%01010000    ; Set interupt masks.
 F119 7EF08E                 JMP   RESET
                      ;*
                      ;* Interrupt vector routines.
                      ;*
 F11C 6E9FDF82        NMI    JMP   [NMIV]
 F120 6E9FDF84        IRQ    JMP   [IRQV]
 F124 6E9FDF86        FIRQ   JMP   [FIRQV]
 F128 6E9FDF88        SWI2   JMP   [SWI2V]
 F12C 6E9FDF8A        SWI3   JMP   [SWI3V]
                      ;* No action goes here
 F130 39              DUMMY  RTS
                      ;*
                      ;*****************************************************
                      ;* Console drivers                                   *
                      ;* ---------------                                   *
                      ;* The system dependant code for the console drivers *
                      ;* fits here. The entries in the jump tables INITAB  *
                      ;* INTAB,OUTTAB and STATAB should be changed to suit *
                      ;* these routines. For a description of the drivers  *
                      ;* for an 6850 acia see section 3 of the general     *
                      ;* Flex adaptation guide (pp6-8).                    *
                      ;*****************************************************
                      ;*
                      ;* LIB CONSOLE
                      ;*
                      ;* Check for character
 F131 3416            STATUS  PSHS    X,D
 F133 7DDF8D                  TST     OPORT      ; video monitor ?
 F136 2610                    BNE     STAT2      ; no,skip flash routine
 F138 BEDFFD                  LDX     FLASH      ; used here as counter
 F13B 2606                    BNE     STAT1      ; if <> 0,go decrement
 F13D BDFB4A                  JSR     FLCUR      ; else toggle cursor
 F140 8E0FA0                  LDX     #$0FA0     ; & reset counter
 F143 301F            STAT1   LEAX    -$01,X
 F145 BFDFFD                  STX     FLASH
 F148 8EF187          STAT2   LDX     #TQINT
 F14B F6DF8C                  LDB     IPORT
 F14E 58                      ASLB
 F14F AD95                    JSR     [B,X]      ; check for interrupt
 F151 3596                    PULS    PC,X,D     ; Z=1 if no interrupt
                      ;* Input char without echo
 F153 3414            INCH1   PSHS    X,B
 F155 8DDA            INC1    BSR     STATUS     ; wait for interrupt
 F157 27FC                    BEQ     INC1
 F159 7DDFFF                  TST     BLANKD     ; cursor blanked ?
 F15C 2703                    BEQ     INC2       ; no,skip
 F15E BDFB4A                  JSR     FLCUR      ; yes,toggle again
 F161 8EF17B          INC2    LDX     #TABIN
 F164 F6DF8C                  LDB     IPORT
 F167 58                      ASLB
 F168 AD95                    JSR     [B,X]      ; get char.into ACCA
 F16A 3594                    PULS    PC,X,B
                      ;* Input character
 F16C 8DE5            INCH    BSR     INCH1
                      ;* Output character
 F16E 3414            OUTCH   PSHS    X,B
 F170 8EF181                  LDX     #TABOUT
 F173 F6DF8D                  LDB     OPORT
 F176 58                      ASLB
 F177 AD95                    JSR     [B,X]
 F179 3594                    PULS    PC,X,B
                      ;* Console I/O function table
 F17B F18D            TABIN   FDB     INKEY
 F17D F193                    FDB     GETA1
 F17F F199                    FDB     GETA2
 F181 F19F            TABOUT  FDB     PUTVID
 F183 F1A2                    FDB     PUTA1
 F185 F1AD                    FDB     PUTA2
 F187 F1B8            TQINT   FDB     QINT0
 F189 F1BE                    FDB     QINT1
 F18B F1C4                    FDB     QINT2
                      ;* Get char from keyboard
 F18D B6FF00          INKEY   LDA     PIA1
 F190 847F                    ANDA    #$7F
 F192 39                      RTS
                      ;* Get char from acia port 1
 F193 B6FF08          GETA1   LDA     ACIA1
 F196 847F                    ANDA    #$7F
 F198 39                      RTS
                      ;* Get char from acia port 2
 F199 B6FF04          GETA2   LDA     ACIA2
 F19C 847F                    ANDA    #$7F
 F19E 39                      RTS
                      ;* Send char to video
 F19F 7EFB1C          PUTVID  JMP     VIDCH
                      ;* Send char to acia port 1
 F1A2 F6FF09          PUTA1   LDB     ACIA1+1    ; check status
 F1A5 C501                    BITB    #$01       ; TX ready ?
 F1A7 27F9                    BEQ     PUTA1      ; no,wait
 F1A9 B7FF08                  STA     ACIA1      ; yes,send char
 F1AC 39                      RTS
                      ;* Send char to acia port 2
 F1AD F6FF05          PUTA2   LDB     ACIA2+1
 F1B0 C501                    BITB    #$01
 F1B2 27F9                    BEQ     PUTA2
 F1B4 B7FF04                  STA     ACIA2
 F1B7 39                      RTS
                      ;* Check for interrupt, port 0 (keyboard)
 F1B8 B6FF01          QINT0   LDA     PIA1+1
 F1BB 8580                    BITA    #$80       ; test flag
 F1BD 39                      RTS                ; if not,Z=1
                      ;* Check for interrupt, port 1 (acia 1)
 F1BE B6FF09          QINT1   LDA     ACIA1+1
 F1C1 8402                    ANDA    #$02
 F1C3 39                      RTS
                      ;* Check for interrupt, port 2 (acia 2)
 F1C4 B6FF05          QINT2   LDA     ACIA2+1
 F1C7 8402                    ANDA    #$02
 F1C9 39                      RTS
                      ;*
                      ;* Disc drive vector table (1 read, 2 write, 3 verify,
                      ;* 4 reset, 5 select, 6 check, 7 quick, 8 init, 9 warm, 10 seek)
                      ;*
 F1CA F231            TABSRT  FDB     RDFLP      ; floppy drive 0
 F1CC F272                    FDB     WRFLP
 F1CE F2A3                    FDB     VRFLP
 F1D0 F2AE                    FDB     RSFLP
 F1D2 F2FC                    FDB     SELD0
 F1D4 F336                    FDB     NVC0Z1
 F1D6 F336                    FDB     NVC0Z1
 F1D8 F336                    FDB     NVC0Z1
 F1DA F336                    FDB     NVC0Z1
 F1DC F2C4                    FDB     SKFLP

 F1DE F231                    FDB     RDFLP      ; floppy drive 1
 F1E0 F272                    FDB     WRFLP
 F1E2 F2A3                    FDB     VRFLP
 F1E4 F2AE                    FDB     RSFLP
 F1E6 F306                    FDB     SELD1
 F1E8 F336                    FDB     NVC0Z1
 F1EA F336                    FDB     NVC0Z1
 F1EC F336                    FDB     NVC0Z1
 F1EE F336                    FDB     NVC0Z1
 F1F0 F2C4                    FDB     SKFLP

 F1F2 F3FB                    FDB     RDDT2      ; Disk typ 2
 F1F4 F415                    FDB     WRDT2      ; 2 is master CF
 F1F6 F336                    FDB     NVC0Z1     ; 3 is slave CF
 F1F8 F367                    FDB     DRVDT2
 F1FA F367                    FDB     DRVDT2
 F1FC F43E                    FDB     CHKDT2
 F1FE F336                    FDB     NVC0Z1
 F200 F45F                    FDB     INIDT2
 F202 F336                    FDB     NVC0Z1
 F204 F336                    FDB     NVC0Z1

 F206 F3FB                    FDB     RDDT2      ; Disk typ 3
 F208 F415                    FDB     WRDT2      ; 2 is master CF
 F20A F336                    FDB     NVC0Z1     ; 3 is slave CF
 F20C F367                    FDB     DRVDT2
 F20E F367                    FDB     DRVDT2
 F210 F43E                    FDB     CHKDT2
 F212 F336                    FDB     NVC0Z1
 F214 F45F                    FDB     INIDT2
 F216 F336                    FDB     NVC0Z1
 F218 F336                    FDB     NVC0Z1

                      ;*
                      ;* DISC I/O
                      ;*
                      ;* Query FDC busy status
 F21A F6FF10          QBUSY   LDB     COMREG     ; get status register
 F21D C501                    BITB    #$01       ; inspect bit 0
 F21F 26F9                    BNE     QBUSY      ; if busy, wait
 F221 39                      RTS

                      * Load FDC command
 F222 8DF6            FCMD    BSR     QBUSY      ; wait until ready
 F224 B7FF10                  STA     COMREG     ; load command

                      ;* Twiddle your thumbs for 100 micro-Secs
 F227 170000          PAUSE   LBSR    PAUS1
 F22A 170000          PAUS1   LBSR    PAUS2
 F22D 170000          PAUS2   LBSR    PAUS3
 F230 39              PAUS3   RTS

                      ;* Read a sector from floppy drive 0/1
 F231 170090          RDFLP   LBSR    SKFLP      ; seek track/sector
 F234 86FF                    LDA     #$FF       ; set DP = $FF
 F236 1E8B                    EXG     A,DP
 F238 3402                    PSHS    A          ; save old DP
 F23A 8684                    LDA     #$84       ; read sector cmd
 F23C 8DE4                    BSR     FCMD       ; load command
 F23E 5F                      CLRB
 F23F 9610            RDFL1   LDA     <COMREG    ; COMREG (status)
 F241 8502                    BITA    #$02       ; data reg full ?
 F243 260C                    BNE     RDFL3      ; yes,branch
 F245 8501                    BITA    #$01       ; cmd executed ?
 F247 26F6                    BNE     RDFL1      ; no,wait
 F249 200F                    BRA     RDFL4
 F24B 9610            RDFL2   LDA     <COMREG    ; status
 F24D 8506                    BITA    #$06       ; ready ?
 F24F 27FA                    BEQ     RDFL2      ; no,wait
 F251 9613            RDFL3   LDA     <DATREG    ; data reg
 F253 A780                    STA     ,X+
 F255 5A                      DECB               ; last byte done ?
 F256 26F3                    BNE     RDFL2      ; no,continue
 F258 20E5                    BRA     RDFL1      ; yes,check status
 F25A 1F89            RDFL4   TFR     A,B        ; ACCB = status
 F25C 3502                    PULS    A          ; restore DP
 F25E 1E8B                    EXG     A,DP
 F260 C510                    BITB    #$10       ; record found ?
 F262 270B                    BEQ     RDFL5      ; yes,exit
 F264 B6FF02                  LDA     SYSREG     ; no,toggle DEN
 F267 8802                    EORA    #$02
 F269 B7FF02                  STA     SYSREG
 F26C 73DFF4                  COM     DEN        ; toggle DEN
 F26F C41C            RDFL5   ANDB    #$1C       ; Z=1 if no error
 F271 39                      RTS

                      ;* Write a sector to floppy drive 0/1
 F272 8D50            WRFLP   BSR     SKFLP      ; seek track/sector
 F274 86FF                    LDA     #$FF       ; change DP
 F276 1E8B                    EXG     A,DP
 F278 3402                    PSHS    A          ; save old DP
 F27A 86A4                    LDA     #$A4       ; write sector cmd
 F27C 8DA4                    BSR     FCMD       ; load cmd
 F27E 5F                      CLRB
 F27F 9610            WRFL1   LDA     <COMREG    ; get status
 F281 8502                    BITA    #$02       ; data reg.empty ?
 F283 260C                    BNE     WRFL3      ; yes,branch
 F285 8501                    BITA    #$01       ; busy ?
 F287 26F6                    BNE     WRFL1      ; yes,wait
 F289 200F                    BRA     WRFL4      ; else,branch
 F28B 9610            WRFL2   LDA     <COMREG    ; check status
 F28D 8506                    BITA    #$06       ; ready ?
 F28F 27FA                    BEQ     WRFL2      ; no,wait
 F291 A680            WRFL3   LDA     ,X+        ; send byte
 F293 9713                    STA     <DATREG
 F295 5A                      DECB               ; all done ?
 F296 26F3                    BNE     WRFL2      ; no,continue
 F298 20E5                    BRA     WRFL1      ; yes,check status
 F29A 1F89            WRFL4   TFR     A,B        ; put status in B
 F29C 3502                    PULS    A          ; restore DP
 F29E 1E8B                    EXG     A,DP
 F2A0 C45C                    ANDB    #$5C       ; test status
 F2A2 39                      RTS                ; Z=1 if no error

                      ;* Verify a sector on floppy drive 0/1
 F2A3 8684            VRFLP   LDA     #$84       ; (read sector cmd)
 F2A5 17FF7A                  LBSR    FCMD       ; load cmd
 F2A8 17FF6F                  LBSR    QBUSY      ; wait 'till finished
 F2AB C418                    ANDB    #$18
 F2AD 39                      RTS                ; Z=1 if no error

                      ;* Restore to track 00 floppy drive 0/1
 F2AE B6FF02          RSFLP   LDA     SYSREG
 F2B1 8A02                    ORA     #$02       ; set single density
 F2B3 B7FF02                  STA     SYSREG
 F2B6 8600                    LDA     #$00       ; restore cmd
 F2B8 BBDFF6                  ADDA    STEP       ; adjust for step rate
 F2BB 17FF64                  LBSR    FCMD       ; load cmd
 F2BE 17FF59                  LBSR    QBUSY      ; wait 'till finished
 F2C1 C458                    ANDB    #$58
 F2C3 39                      RTS                ; z=1 if no error

                      ;* Seek to track/sector floppy drive 0/1
 F2C4 F7FF12          SKFLP   STB     COMREG+2   ; rqud. sector
 F2C7 B7FF13                  STA     DATREG     ; reqd. track
 F2CA B6FF02                  LDA     SYSREG
 F2CD 7DDFF4                  TST     DEN        ; double density ?
 F2D0 270B                    BEQ     SDEN       ; no,set single
 F2D2 7DFF13                  TST     DATREG     ; yes,set double except if
 F2D5 2706                    BEQ     SDEN       ; track 0 => single density
 F2D7 84FD                    ANDA    #$FD
 F2D9 C112                    CMPB    #$12       ; sector/track
 F2DB 2004                    BRA     DDEN
 F2DD 8A02            SDEN    ORA     #$02       ; single density
 F2DF C10A                    CMPB    #$0A       ; sector/track
 F2E1 2F04            DDEN    BLE     SKFL1
 F2E3 84BF                    ANDA    #$BF
 F2E5 2002                    BRA     SKFL2
 F2E7 8A40            SKFL1   ORA     #$40
 F2E9 B7FF02          SKFL2   STA     SYSREG
 F2EC 8610                    LDA     #$10       ; seek sector cmd
 F2EE BBDFF6                  ADDA    STEP       ; adjusted for step rate
 F2F1 17FF2E                  LBSR    FCMD       ; load cmd
 F2F4 17FF23                  LBSR    QBUSY      ; wait 'till finished
 F2F7 C510                    BITB    #$10       ; check status
 F2F9 16FF2B                  LBRA    PAUSE      ; exit via pause

                      ;* Select floppy drive 0
 F2FC B6FF02          SELD0   LDA     SYSREG
 F2FF 84FE                    ANDA    #$FE       ; set DRV 0
 F301 F6DFF7                  LDB     SPEED
 F304 2008                    BRA     SETD

                      ;* Select floppy drive 1
 F306 B6FF02          SELD1   LDA     SYSREG
 F309 8A01                    ORA     #$01
 F30B F6DFF8                  LDB     TSTEP
 F30E B7FF02          SETD    STA     SYSREG
 F311 F7DFF6                  STB     STEP
 F314 E603                    LDB     $03,X      ; get drive No
 F316 F1DFB6                  CMPB    CURDRV     ; same as current ?
 F319 271B                    BEQ     NVC0Z1     ; yes,branch
 F31B F7DFB6                  STB     CURDRV     ; else,update current
 F31E B6FF11                  LDA     COMREG+1   ; set TRACK & DEN
 F321 F6DF8F                  LDB     TRACK
 F324 B7DF8F                  STA     TRACK
 F327 F7FF11                  STB     COMREG+1
 F32A B6DFF4                  LDA     DEN
 F32D F6DFF5                  LDB     DEN1
 F330 B7DFF5                  STA     DEN1
 F333 F7DFF4                  STB     DEN

                      ;* Return with N,V,C clear, Z set
                      ;* No error
 F336 5F              NVC0Z1  CLRB
 F337 5D                      TSTB
 F338 1CFE                    ANDCC   #$FE
 F33A 39                      RTS

                      ;* Return with N,V,Z clear, C set
                      ;* Error
 F33B C640            NVZ0C1  LDB     #$40
 F33D 5D                      TSTB
 F33E 1A01                    ORCC    #$01
 F340 39                      RTS

                      ;* Set DP to $FF,speed to fast
 F341 1E8B            FAST    EXG     A,DP       ; save present DP
 F343 B7DFFC                  STA     REGDP
 F346 86FF                    LDA     #$FF       ; set DP = $FF
 F348 1E8B                    EXG     A,DP
 F34A B7FFD9                  STA     SET_R1     ; set Fast speed
 F34D 39                      RTS

                      ;* Restore DP,speed to slow
 F34E B6DFFC          SLOW    LDA     REGDP      ; restore former DP
 F351 1E8B                    EXG     A,DP
 F353 7DDFF9                  TST     PSPEED     ; test current speed
 F356 260E                    BNE     SLOW2
 F358 B7FFD7                  STA     SET_R0     ; set slow speed
 F35B B7FFD8                  STA     CLR_R1
 F35E 7D0000                  TST     >$0000
 F361 21EB                    BRN     SLOW
 F363 B7FFD6                  STA     CLR_R0
 F366 39              SLOW2   RTS

                      ;* =====================================================================
                      ;* VARIOUS IDE / 8255 DISK ROUTINES
                      ;* =====================================================================

                      ;*
                      ;* Select master / slave CF
 F367 3412            DRVDT2      PSHS    A,X
 F369 7DDE7E                      TST     MSTCFOK             ; check if master cf present ?
 F36C 271B                        BEQ     DRVERR              ; no exit with error
 F36E A603                        LDA     3,X                 ; get Flex disk number
 F370 8EDF9D                      LDX     #DDSTAB
 F373 E686                        LDB     A,X                 ; get physical disk number
 F375 86E0                        LDA     #LBA3MST            ; master cf by default
 F377 C102                        CMPB    #$02                ; master asked ?
 F379 2707                        BEQ     ENDDRVDT2           ; yes exit ok
 F37B 7DDE7F                      TST     SLVCFOK             ; if not master then its slave - present ?
 F37E 2709                        BEQ     DRVERR              ; no exit with error
 F380 86F0                        LDA     #LBA3SLV

 F382 B7DE7D          ENDDRVDT2   STA     LBA3                ; update LBA3 in ram
 F385 8DAF                        BSR     NVC0Z1              ; no error
 F387 3592                        PULS    A,X,PC

 F389 8DB0            DRVERR      BSR     NVZ0C1              ; error
 F38B 3592                        PULS    A,X,PC
                      ;*
                      ;* Compute lba number from flex track/sector
                      ;* Check if flex disk number stored at 3,x is master ($02) or slave ($03) cf
                      ;* and set cf master or slave select bit in lba3 accordingly
                      ;*
                      ;* The cf disk is assumed to be 122 tracks (00$ to $79) of 256 sectors ($00 to $ff)
                      ;* This is a 15990784 bytes disk in 31232 lba of 512 bytes
                      ;*
                      ;* A*256+B IS SAME AS PUT REG A INTO MSB OF A WORD THEN ADD REG B
                      ;* SO REG A CAN BE DIRECTLY USED AS LBA1 AND REG B AS LBA0
                      ;
                      ;* Input : A = flex track
                      ;*         B = flex sector
                      ;*         X = flex fcb address
                      ;*
                      ;* Output : lba0 and lba1 updated in ram storage zone
 F38D B7DE7B          SETLBA      STA     LBA1                ; store lba in table
 F390 F7DE7A                      STB     LBA0                ; fall into transfer routine
                      ;*
                      ;* Transfer params table from memory to cf
                      ;* and enable data
 F393 3436            TFRPARM     PSHS    A,B,X,Y
 F395 8EDE7E                      LDX     #LBA3+1             ; load table address + 1
 F398 108E000E                    LDY     #IDE_LBA3           ; load 1st cf register to write

 F39C 8D18            PARMLOP     BSR     CMDWAIT
 F39E 1F20                        TFR     Y,D                 ; get Y lsb into B
 F3A0 A682                        LDA     ,-X                 ; with pre decr load param from table
 F3A2 8D26                        BSR     WRT_IDE             ; write param in cf
 F3A4 313F                        LEAY    -1,Y                ; change cf register
 F3A6 108C0008                    CMPY    #IDE_SET_FEAT-1     ; check if 6 params loaded in cf
 F3AA 26F0                        BNE     PARMLOP             ; if 6 params not loaded do again

 F3AC 8D08                        BSR     CMDWAIT
 F3AE 86EF                        LDA     #IDE_CMD_SET_FEAT   ; now enable features
 F3B0 C60F                        LDB     #IDE_COMMAND
 F3B2 8D16                        BSR     WRT_IDE
 F3B4 35B6                        PULS    A,B,X,Y,PC
                      ;*
                      ;* Check cf error status
                      ;CFERR       LDB     #IDE_STATUS         ; ask status register
                      ;            BSR     READ_IDE
                      ;            BITA    #ERRBIT             ; read error bit
                      ;            RTS                         ; return with z clear if error
                      ;*
                      ;* Wait cf card command ready
 F3B6 8D09            CMDWAIT     BSR     DATWAIT             ; wait data ready
 F3B8 C60F            CWLOOP      LDB     #IDE_STATUS         ; ask status register
 F3BA 8D26                        BSR     READ_IDE
 F3BC 8540                        BITA    #RDYBIT             ; read ready bit
 F3BE 27F8                        BEQ     CWLOOP              ; wait ready bit set
 F3C0 39                          RTS
                      ;*
                      ;* Wait cf card data ready with time out
 F3C1 C60F            DATWAIT     LDB     #IDE_STATUS         ; ask status register
 F3C3 8D1D                        BSR     READ_IDE            ; A receive status register
 F3C5 8580                        BITA    #BSYBIT             ; read busy bit
 F3C7 26F8                        BNE     DATWAIT             ; not clear ? yes do again
 F3C9 39                          RTS
                      ;*
                      ;* Do a one byte write cycle to ide
                      ;* B = cf register where to write
                      ;* A = byte to write
 F3CA 3402            WRT_IDE     PSHS    A
 F3CC 8680                        LDA     #WR_IDE_8255        ; set 8255 A/B/C for output
 F3CE B7FF1F                      STA     PORTCTRL
 F3D1 3502                        PULS    A
 F3D3 B7FF1C                      STA     PORTA               ; prepare lsb on output d0-d7
 F3D6 F7FF1E                      STB     PORTC               ; set cf register address
 F3D9 CA20                        ORB     #IDE_WR             ; assert wr line
 F3DB F7FF1E                      STB     PORTC
 F3DE C820                        EORB    #IDE_WR                             ; prepare for release wr line
 F3E0 2012                        BRA     ENDIDERW
                      ;*
                      ;* Do a one byte read cycle from ide
                      ;* B = cf register to read
                      ;* A = byte read
 F3E2 8692            READ_IDE    LDA     #RD_IDE_8255        ; set 8255 A/B for input C for output
 F3E4 B7FF1F                      STA     PORTCTRL
 F3E7 F7FF1E                      STB     PORTC               ; set cf register address
 F3EA CA40                        ORB     #IDE_RD             ; assert rd line
 F3EC F7FF1E                      STB     PORTC
 F3EF B6FF1C                      LDA     PORTA               ; read lsb from d0-d7
 F3F2 C840                        EORB    #IDE_RD             ; prepare for rd line release 
                                  
 F3F4 F7FF1E          ENDIDERW    STB     PORTC               ; release line
 F3F7 7FFF1E                                  CLR     PORTC               ; release ide device
 F3FA 39                          RTS
                      ;*
                      ;* Read sector from disk typ 8255 / ide
                      ;* (A=track,B=sector,X=addr of a sector buffer)
 F3FB 3436            RDDT2       PSHS    Y,X,B,A

 F3FD 8D8E                        BSR     SETLBA              ; compute lba and set params in cf

 F3FF 8DB5                        BSR     CMDWAIT
 F401 8620                        LDA     #IDE_CMD_READ       ; send read command to the cf card
 F403 C60F                        LDB     #IDE_COMMAND        ; load command register address
 F405 8DC3                        BSR     WRT_IDE             ; send command to the cf card

 F407 8D2C            RDLOOP      BSR     CHKDRQ
 F409 2725                        BEQ     RWEXIT              ; Z set ? yes end of loop
 F40B 8DB4                        BSR     DATWAIT
 F40D C608                        LDB     #IDE_DATA
 F40F 8DD1                        BSR     READ_IDE            ; read the data byte from cf
 F411 A780                        STA     ,X+                 ; write it to the buffer
 F413 20F2                        BRA     RDLOOP
                      ;*
                      ;* Write a sector to disk typ 8255 / ide
                      ;* (A=track,B=sector,X=addr of a sector buffer)
 F415 3436            WRDT2       PSHS    Y,X,B,A

 F417 BDF38D                      JSR     SETLBA              ; compute lba and set params in cf

 F41A 8D9A                        BSR     CMDWAIT
 F41C 8630                        LDA     #IDE_CMD_WRITE      ; send write command to the cf card
 F41E C60F                        LDB     #IDE_COMMAND        ; load command register address
 F420 8DA8                        BSR     WRT_IDE             ; send command to the cf card

 F422 8D11            WRLOOP      BSR     CHKDRQ
 F424 270A                        BEQ     RWEXIT              ; Z set ? yes end of loop
 F426 8D99                        BSR     DATWAIT
 F428 A680                        LDA     ,X+                 ; read the byte from the buffer
 F42A C608                        LDB     #IDE_DATA           ; write the data byte to cf
 F42C 8D9C                        BSR     WRT_IDE
 F42E 20F2                        BRA     WRLOOP

 F430 BDF336          RWEXIT      JSR     NVC0Z1              ;  set cc with no error & rts
 F433 35B6                        PULS    Y,X,B,A,PC
                      ;*
                      ;* Check cf DRQ bit
                      ;* Return Z=0 if DRQ set
                      ;*        Z=1 if DRQ not set
 F435 8D8A            CHKDRQ      BSR     DATWAIT
 F437 C60F                        LDB     #IDE_STATUS
 F439 8DA7                        BSR     READ_IDE
 F43B 8508                        BITA    #DRQBIT
 F43D 39                          RTS
                      ;*
                      ;* Chkrdy disk typ 2 & 3
                      ;* We just check if CF has been detected by init routine
 F43E 3412            CHKDT2      PSHS    X,A
 F440 7DDE7E                      TST     MSTCFOK
 F443 2715                        BEQ     NOTRDY              ; no master then also no slave exit not ready

 F445 A603                        LDA     3,X                 ; load flex disk number
 F447 8EDF9D                      LDX     #DDSTAB
 F44A E686                        LDB     A,X                 ; load physical disk number
 F44C C102                        CMPB    #$02                ; master cf asked ?
 F44E 2705                        BEQ     RDY                 ; yes all ok
 F450 7DDE7F                      TST     SLVCFOK             ; if master cf not asked then it is slave
 F453 2705                        BEQ     NOTRDY              ; slave present ? no exit not ready

 F455 BDF336          RDY         JSR     NVC0Z1              ; no error - clear C - set Z
 F458 3592                        PULS    X,A,PC

 F45A BDF33B          NOTRDY      JSR     NVZ0C1              ; error - clear Z - set C
 F45D 3592                        PULS    X,A,PC
                      ;*
                      ;* Detect and init disk typ 2 & 3 CF on 8255 ide port
 F45F C60E            INIDT2      LDB     #IDE_LBA3           ; set lba3 for master cf
 F461 86E0                        LDA     #LBA3MST
 F463 B7DE7D                      STA     LBA3                ; keep ram table sync 
 F466 BDF3CA                      JSR     WRT_IDE

 F469 CC0000                      LDD     #$0000
 F46C FDDE7E                      STD     MSTCFOK             ; clear cf present flags
 F46F 108EDE7E                                LDY     #MSTCFOK            ; Y point to master flag

 F473 8EFFFE          ILOOP       LDX     #$FFFE              ; prepare for time out
 F476 C60F            ILOOP1      LDB     #IDE_STATUS         ; ask status register
 F478 BDF3E2                      JSR     READ_IDE
 F47B 8580                        BITA    #BSYBIT             ; read busy bit
 F47D 2706                        BEQ     MSTOK               ; if clear cf ok
 F47F 301F                        LEAX    -1,X                ; countdown
 F481 2717                        BEQ     ENDINI              ; time out end cf int (if no master then no slave)
 F483 20F1                        BRA     ILOOP1              ; do again
 F485 8540            MSTOK       BITA    #RDYBIT             ; must also check ready bit set
 F487 2711                        BEQ     ENDINI              ; error set ? yes end cf init
 F489 6CA0                        INC     ,Y+                 ; no set cf flag - Y point to next flag

 F48B 108CDE80                                CMPY    #SLVCFOK+1          ; master and slave done ?
 F48F 2709                                    BEQ     ENDINI              ; yes end of init  
                                              
 F491 C60E                        LDB     #IDE_LBA3           ; set lba3 for slave cf
 F493 86F0                        LDA     #LBA3SLV
 F495 BDF3CA                      JSR     WRT_IDE
 F498 20D9                        BRA     ILOOP               ; do init again for slave cf

 F49A C60E            ENDINI      LDB     #IDE_LBA3           ; set lba3 for master cf
 F49C 86E0                        LDA     #LBA3MST
 F49E BDF3CA                      JSR     WRT_IDE
 F4A1 39                          RTS

                      ;* =====================================================================
                      ;* END OF VARIOUS IDE / 8255 DISK ROUTINES
                      ;* =====================================================================

                      ;*
                      ;*****************************************
                      ;* Disk drivers                          *
                      ;* ------------                          *
                      ;* The system dependant code for the     *
                      ;* disc drivers fits here. Two tables    *
                      ;* must be included. These are DDSTAB a  *
                      ;* four byte table that defines which of *
                      ;* the (up to four) following sets of    *
                      ;* jump tables to use, and TABSRT the    *
                      ;* jump tables themselves. For a full    *
                      ;* description of the floppy drivers see *
                      ;* section 4 (pp9-14) of the general     *
                      ;* Flex adaptation guide.                *
                      ;*****************************************
                      ;*
                      ;* LIB DISK
                      ;* Read sector routine.
                      ;* Entry: (X) = address where sector is to be placed.
                      ;*        (A) = Track  number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error code  (z)=1 if no error.
 F4A2 6E9FDFA1        READ    JMP     [REAVEC]
                      ;*
                      ;* Write track routine.
                      ;* Entry: (X) = Address of area of memory from which the data will be taken.
                      ;*        (A) = Track number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error condition, (Z)=1 no an error.
 F4A6 6E9FDFA3        WRITE   JMP     [WRIVEC]
                      ;*
                      ;* Verify sector routine.
                      ;* Entry: no parameters.
                      ;* Exit:  (B) = Error condition (Z)=1 if no error.
 F4AA 6E9FDFA5        VERIFY  JMP     [VERVEC]
                      ;*
                      ;* Restore drive to track 00.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=1 if no error.
 F4AE 8D07            RST     BSR     DRV        ; Select drive first.
 F4B0 2701                    BEQ     RST1
 F4B2 39                      RTS
 F4B3 6E9FDFA7        RST1    JMP     [RSTVEC]
                      ;*
                      ;* Select current drive.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=0 and (c)=1 if error.
                      ;*        (B) = $0F if non existant drive.
 F4B7 3430            DRV     PSHS    X,Y
 F4B9 E603                    LDB     3,X        ; Get driver type.
 F4BB 8EDF9D                  LDX     #DDSTAB
 F4BE A685                    LDA     B,X
 F4C0 81FF                    CMPA    #$FF       ; Is the drive nonexistant?
 F4C2 2608                    BNE     DRIVE1
 F4C4 3530                    PULS    X,Y
 F4C6 C60F                    LDB     #$0F
 F4C8 5D                      TSTB
 F4C9 1A01                    ORCC    #$01
 F4CB 39                      RTS
 F4CC C614            DRIVE1  LDB     #20        ; Get correct table start address.
 F4CE 3D                      MUL
 F4CF 8EF1CA                  LDX     #TABSRT
 F4D2 308B                    LEAX    D,X
 F4D4 108EDFA1                LDY     #REAVEC    ; Copy table into ram.
 F4D8 C614                    LDB     #20
 F4DA A680            DRIVE2  LDA     ,X+
 F4DC A7A0                    STA     ,Y+
 F4DE 5A                      DECB
 F4DF 26F9                    BNE     DRIVE2
 F4E1 3530                    PULS    X,Y
 F4E3 6E9FDFA9                JMP     [DRVVEC]
                      ;*
                      ;* Check for drive ready.
                      ;* Entry: (X) = FCB address (3,X contains drive number)>
                      ;* Exit:  (B) = Error condition, (Z)=0 AND (C)=1 if drive is not ready.
 F4E7 6E9FDFAB        CHKRDY  JMP     [CHKVEC]
                      ;*
                      ;* Quick drive ready check.
                      ;* Entry: (X) = FCB address (3,X contains drive number).
                      ;* Exit:  (B) = Error condition, (Z)=0 AND (c)=1 if drive not ready.
 F4EB 6E9FDFAD        QUICK   JMP     [QUIVEC]
                      ;*
                      ;* Init (cold start).
                      ;* Entry: no parameters.
                      ;* Exit: no change.
 F4EF 4F              DINIT   CLRA
 F4F0 B7DF8E          DINIT1  STA     DRIVE      ; Init each valid drive in turn.
 F4F3 8EDF8B                  LDX     #(DRIVE-3)
 F4F6 8DBF                    BSR     DRV
 F4F8 2504                    BCS     DINIT2
 F4FA AD9FDFAF                JSR     [INIVEC]
 F4FE B6DF8E          DINIT2  LDA     DRIVE
 F501 4C                      INCA
 F502 8103                    CMPA    #3
 F504 26EA                    BNE     DINIT1
 F506 39                      RTS
                      ;*
                      ;* Warm start.
                      ;* Entry: no parameters.
                      ;* Exit: no change.
 F507 6E9FDFB1        WARM    JMP     [WARVEC]
                      ;*
                      ;* Seek track.
                      ;* Entry: (A) = Track number.
                      ;*        (B) = Sector number.
                      ;* Exit:  (B) = Error condition, (Z)=1 if no error.
 F50B 6E9FDFB3        SEEK    JMP     [SEEVEC]
                      ;*
                      ;*******************************
                      ;* Common monitor subroutines. *
                      ;*******************************
                      ;*
                      ;* Print a CR followed by a LF.
                      ;* Entry: no parameters.
                      ;* Exit: (A) destroyed.
 F50F 0A0D04          CRLFS   FCB     $0A,$0D,4
 F512 3410            PCRLF   PSHS    X
 F514 8EF50F                  LDX     #CRLFS     ; Get CR,LF string,
 F517 8D05                    BSR     PDATA1     ; and print it.
 F519 3590                    PULS    X,PC
                      ;*
                      ;* Print character string .
                      ;* Entry: (X) = Pointer to character string.
                      ;* Exit:  (X) = Pointer to end of string token Hex(04).
                      ;*        (A)   Destroyed.
 F51B BDF16E          P       JSR     OUTCH      ; Print char.
 F51E A680            PDATA1  LDA     ,X+        ; Get character pointed to by X.
 F520 8104                    CMPA    #$04       ; End of string token?
 F522 26F7                    BNE     P          ; If not then print char.
 F524 39                      RTS
                      ;*
                      ;* Print character string preceded by a CR,LF.
                      ;* Entry: (X) = Pointer to character string.
                      ;* Exit:  (X) = Pointer to end of string token Hex(04).
                      ;*        (A) = Destroyed.
 F525 8DEB            PSTRNG  BSR     PCRLF
 F527 8DF5                    BSR     PDATA1
 F529 39                      RTS
                      ;*
                      ;* Print the A reg.
                      ;* Entry :- (A) = Data to be printed.
 F52A 3416            PRINTA  PSHS    D,X
 F52C B7DF91                  STA     TEMP
 F52F 8EDF91                  LDX     #TEMP
 F532 8D7F                    BSR     OUT2HS
 F534 3596                    PULS    D,X,PC
                      ;*
                      ;* Print the X reg.
                      ;* Entry :- (X) = Data to be printed.
 F536 3416            PRINTX  PSHS    D,X
 F538 BFDF92                  STX     XTEMP
 F53B 8EDF92                  LDX     #XTEMP
 F53E 8D71                    BSR     OUT4HS
 F540 3596                    PULS    D,X,PC
                      ;*
                      ;* Delay routine.
                      ;* Entry: (X) = Delay time in milli seconds.
                      ;* Exit:  no change.
 F542 3436            DELAY   PSHS    D,X,Y
 F544 108E0034        DELAY1  LDY     #52 Delay
 F548 7DDFF9                  TST     PSPEED
 F54B 2704                    BEQ     DELAY2
 F54D 108E0068                LDY     #104       ; Twice delay for 2Mhz.
 F551 3D              DELAY2  MUL
 F552 313F                    LEAY    -1,Y
 F554 26FB                    BNE     DELAY2
 F556 301F                    LEAX    -1,X
 F558 26EA                    BNE     DELAY1
 F55A 35B6                    PULS    D,X,Y,PC
                      ;*
                      ;* Build a four hex digit address.
                      ;* Entry: no parameters.
                      ;* Exit:  (X) = Address.
                      ;*        (A) = Destroyed.
                      ;*        (B) = Destroyed.
 F55C 8D09            BADDR   BSR     BYTE       ; Get 1st char.
 F55E 1F89                    TFR     A,B
 F560 8D05                    BSR     BYTE       ; and next.
 F562 1E89                    EXG     A,B
 F564 1F01                    TFR     D,X                    Put in X.
 F566 39                      RTS
                      ;*
                      ;* Get a two digit hex byte.
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Byte.
 F567 3404            BYTE    PSHS    B
 F569 8D21                    BSR     INHEX      ; Get hex digit.
 F56B 48                      ASLA
 F56C 48                      ASLA               ; Shift to msb.
 F56D 48                      ASLA
 F56E 48                      ASLA
 F56F 1F89                    TFR     A,B        ; Save in B.
 F571 8D19                    BSR     INHEX      ; Get next digit.
 F573 3404                    PSHS    B
 F575 ABE0                    ADDA    ,S+        ; Add together bytes.
 F577 3584             PULS B,PC
                      ;*
                      ;* Print left hex digit.
                      ;* Entry: (A) = Byte containing digit.
                      ;* Exit:  (A) = Byte containing shifted digit.
 F579 44              OUTHL   LSRA
 F57A 44                      LSRA
 F57B 44                      LSRA
 F57C 44                      LSRA
                      ;*
                      ;* Output right hex digit.
                      ;* Entry: (A) = Byte containing digit.
                      ;* Exit:  (A) = Ascii coded digit.
 F57D 840F            OUTHR   ANDA    #$0F       ; Get four bits only.
 F57F 8B30                    ADDA    #$30       ; Add ascii zero.
 F581 8139                    CMPA    #$39       ; Numeric overflow?
 F583 1023FBE7                LBLS    OUTCH
 F587 8B07                    ADDA    #$07       ; Must be hex.
 F589 7EF16E                  JMP    OUTCH
                      ;*
                      ;* Input a valid hex character (If not hex then backspace).
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Valid hex char.
 F58C BDF16C          INHEX   JSR     INCH
 F58F 8030                    SUBA    #$30       ; Remove ascii bias.
 F591 2B0F                    BMI     NOTHEX
 F593 8109                    CMPA    #$09       ; Number?
 F595 2F0A                    BLE     INHEX1     ; Yes.
 F597 8111                    CMPA    #$11       ; Keep testing.
 F599 2B07                    BMI     NOTHEX
 F59B 8116                    CMPA    #$16
 F59D 2E03                    BGT     NOTHEX
 F59F 8007                    SUBA    #$07
 F5A1 39              INHEX1  RTS
 F5A2 8608            NOTHEX  LDA     #$08       ; If not a number
 F5A4 BDF16E                  JSR     OUTCH      ; Print a backspace and try again.
 F5A7 20E3                    BRA     INHEX
                      ;*
                      ;* Hex print routines.
                      ;* Entry: (X) = Pointer to a one or two byte hex number.
                      ;* Exit:  (A) = Destroyed.
 F5A9 A684            OUT2H   LDA     ,X         ;Output two hex chars.
 F5AB 8DCC            OUT2HA  BSR     OUTHL
 F5AD A680                    LDA     ,X+
 F5AF 20CC                    BRA     OUTHR
 F5B1 8DF6            OUT4HS  BSR     OUT2H      ; Output 4 hex chars + space.
 F5B3 8DF4            OUT2HS  BSR     OUT2H      ; Output 2 hex chars + space.
                      ;*
                      ;* Output a space.
                      ;* Entry: no parameters.
                      ;* Exit   (A) = Destroyed.
 F5B5 8620            OUTS    LDA     #' '       ; Output space.
 F5B7 7EF16E                  JMP    OUTCH
                      ;*
                      ;* Random number generator.
                      ;* Entry: no parameters.
                      ;* Exit:  (A) = Random number from 0 to 255.
 F5BA 3404            RANDOM  PSHS B
 F5BC C608                    LDB #8
 F5BE B6DF9B          RPT     LDA RNDM+3
 F5C1 48                      ASLA
 F5C2 48                      ASLA
 F5C3 48                      ASLA
 F5C4 B8DF9B                  EORA RNDM+3
 F5C7 48                      ASLA
 F5C8 48                      ASLA
 F5C9 79DF98                  ROL RNDM
 F5CC 79DF99                  ROL RNDM+1
 F5CF 79DF9A                  ROL RNDM+2
 F5D2 79DF9B                  ROL RNDM+3
 F5D5 5A                      DECB
 F5D6 26E6                    BNE RPT
 F5D8 B6DF98                  LDA RNDM
 F5DB 3584                    PULS B,PC
                      ;*
                      ;**************************************
                      ;* Extra system subroutines fit here. *
                      ;**************************************
                      ;* LIB SUBS
                      ;*
                      ;* Get Time string from RTC
 F5DD 3416            GETTIM  PSHS    X,D
 F5DF C60A                    LDB     #$0A
 F5E1 8D07            GTIM2   BSR     GETRTC
 F5E3 A780                    STA     ,X+
 F5E5 5A                      DECB
 F5E6 26F9                    BNE     GTIM2
 F5E8 3596                    PULS    PC,X,D
                      ;* Get a byte from RTC
 F5EA 860A            GETRTC  LDA     #$0A
 F5EC B7FF18                  STA     RTC
 F5EF B6FF19                  LDA     RTC+1
 F5F2 2BF6                    BMI     GETRTC
 F5F4 F7FF18                  STB     RTC
 F5F7 B6FF19                  LDA     RTC+1
 F5FA 39                      RTS
                      ;* Put time string to RTC
 F5FB 3416            PUTTIM  PSHS    X,D
 F5FD C60A                    LDB     #$0A
 F5FF A680            PTIM2   LDA     ,X+
 F601 8D05                    BSR     PUTRTC
 F603 5A                      DECB
 F604 26F9                    BNE     PTIM2
 F606 3596                    PULS    PC,X,D
                      ;* Put a byte to RTC
 F608 3402            PUTRTC  PSHS    A
 F60A 860A            PRTC2   LDA     #$0A
 F60C B7FF18                  STA     RTC
 F60F B6FF19                  LDA     RTC+1
 F612 2BF6                    BMI     PRTC2
 F614 F7FF18                  STB     RTC
 F617 3502                    PULS    A
 F619 B7FF19                  STA     RTC+1
 F61C 39                      RTS
                      ;* Sound a tone
 F61D 3412            BEEP    PSHS    X,A
 F61F B6FF02                  LDA     SYSREG
 F622 8A08                    ORA     #$08
 F624 B7FF02                  STA     SYSREG
 F627 8E0064                  LDX     #$0064
 F62A BDF542                  JSR     DELAY
 F62D B6FF02                  LDA     SYSREG
 F630 84F7                    ANDA    #$F7
 F632 B7FF02                  STA     SYSREG
 F635 3592                    PULS    PC,X,A
                      ;* Enter from monitor JF cmd. on entry X=CD00 or CD03
 F637 B6FF02          MAPOUT  LDA     SYSREG
 F63A 84FB                    ANDA    #$FB
 F63C B7FF02                  STA     SYSREG
 F63F 6E84                    JMP     ,X

                      ;*************************************
                      ;* Graphic functions for the NEC7220A
                      ;*************************************
                      ;*
                      ;* Send a command to GDC
 F641 4D              GCOM    TSTA               ; reset ?
 F642 270B                    BEQ     GCOM2      ; yes, send at once
 F644 3402                    PSHS    A          ; else, savec cmd
 F646 B6FF14          GCOM1   LDA     GDC        ; get status
 F649 8504                    BITA    #$04       ; FIFO empty ?
 F64B 27F9                    BEQ     GCOM1      ; no, wait
 F64D 3502                    PULS    A          ; recover command
 F64F B7FF15          GCOM2   STA     GDC+1      ; send it
 F652 39                      RTS
                      ;*
                      ;* Send a parameter to GDC
                      ;*
 F653 3402            GPRM    PSHS    A          ; store parameter
 F655 B6FF14          GPRM2   LDA     GDC        ; wait until FIFO empty
 F658 8504                    BITA    #$04
 F65A 27F9                    BEQ     GPRM2
 F65C 3502                    PULS    A
 F65E B7FF14                  STA     GDC        ; send parameter
 F661 39                      RTS
                      ;*
                      ;* Get a parameter from GDC
                      ;*
 F662 B6FF14          GPRMI   LDA     GDC        ; get status
 F665 8501                    BITA    #$01       ; data ready ?
 F667 27F9                    BEQ     GPRMI      ; no, wait
 F669 B6FF15                  LDA     GDC+1      ; read FIFO
 F66C 39                      RTS
                      ;*
                      ;* Load the mask register
                      ;*
 F66D 3406            MASK    PSHS    D
 F66F 864A                    LDA     #$4A       ; send 'mask' command
 F671 8DCE                    BSR     GCOM
 F673 1F10                    TFR     X,D        ; get mask bytes
 F675 1E89                    EXG     A,B        ; reverse for FIFO
 F677 8DDA                    BSR     GPRM       ; send 2nd
 F679 1E89                    EXG     A,B
 F67B 8DD6                    BSR     GPRM       ; send 1st
 F67D 3586                    PULS    PC,D
                      ;*
                      ;* Define drawing mode
                      ;*
 F67F 3416            SETPEN  PSHS    X,D
 F681 8403                    ANDA    #$03       ; setup 'w.data' cmd
 F683 8A20                    ORA     #$20
 F685 8DBA                    BSR     GCOM       ; send it
 F687 1F10                    TFR     X,D        ; get profile word
 F689 F7DFC4                  STB     MDFC4      ; save it
 F68C B7DFC3                  STA     GPARAM
 F68F 8EDFBD                  LDX     #PART1+2
 F692 8D02                    BSR     SETPAT
 F694 3596                    PULS    PC,X,D
                      ;*
                      ;* Define graphics pattern
                      ;*
 F696 3416            SETPAT  PSHS    X,D
 F698 8678                    LDA     #$78       ; 'pram' cmd starting
 F69A 8DA5                    BSR     GCOM       ; with param.No.8
 F69C C608                    LDB     #$08       ; load 8 parameters,
 F69E 3008                    LEAX    $08,X      ; taken from ram
 F6A0 A682            SETP2   LDA     ,-X        ; pointed to by X,
 F6A2 8DAF                    BSR     GPRM       ; in reverse order (FIFO)
 F6A4 5A                      DECB
 F6A5 26F9                    BNE     SETP2
 F6A7 3596                    PULS    PC,X,D
                      ;*
                      ;* Start figure drawing
                      ;*
 F6A9 3416            FIGSF   PSHS    X,D
 F6AB 864C                    LDA     #$4C       ; 'figs' command
 F6AD 8D92                    BSR     GCOM       ; Load [B] drawing parameters
 F6AF 8EDFCD                  LDX     #GFIGS     ; from scratch ram to GDCRAM
 F6B2 A684                    LDA     ,X         ; NB. All 2-byte parameters are
 F6B4 8D9D                    BSR     GPRM       ; loaded low byte first to
 F6B6 5A                      DECB               ; maintain Fifo stack.
 F6B7 270E                    BEQ     FIGS3
 F6B9 A602            FIGS2   LDA     $02,X
 F6BB 8D96                    BSR     GPRM
 F6BD A601                    LDA     $01,X
 F6BF 3002                    LEAX    $02,X
 F6C1 8D90                    BSR     GPRM
 F6C3 5A                      DECB
 F6C4 5A                      DECB
 F6C5 26F2                    BNE     FIGS2
                      ; Load the GDCRAM into the drawing processor & draw.
 F6C7 866C            FIGS3   LDA     #$6C       ; 'figd' command
 F6C9 17FF75                  LBSR    GCOM
 F6CC 3596                    PULS    PC,X,D
                      ;*
                      ;* Start graphics drawing
                      ;*
 F6CE 3416            FIGSG   PSHS    X,D        ; Load [B] drawing parameters
 F6D0 864C                    LDA     #$4C       ; from scratch ram to GDCRAM
 F6D2 17FF6C                  LBSR    GCOM       ; NB. All 2-byte parameters are
 F6D5 8EDFCD                  LDX     #GFIGS     ; loaded low byte first to
 F6D8 A684                    LDA     ,X         ; maintain Fifo stack.
 F6DA 17FF76                  LBSR    GPRM
 F6DD 5A                      DECB
 F6DE 2710                    BEQ     FIGG3
 F6E0 A602            FIGG2   LDA     $02,X
 F6E2 17FF6E                  LBSR    GPRM
 F6E5 A601                    LDA     $01,X
 F6E7 3002                    LEAX    $02,X
 F6E9 17FF67                  LBSR    GPRM
 F6EC 5A                      DECB
 F6ED 5A                      DECB
 F6EE 26F0                    BNE     FIGG2
 F6F0 8668            FIGG3   LDA     #$68       ; 'gchrd' command
 F6F2 17FF4C                  LBSR    GCOM       ; Fill area to pattern stored in GDCRAM
 F6F5 3596                    PULS    PC,X,D     ; (ie. Draw graphics character)
                      ;*
                      ;* Define display partitions. On entry,
                      ;*     X=Pt.1 start
                      ;*     D=Pt.2 start
                      ;*     Y=Pt.1 length
                      ;*     U=Pt.2 length
                      ;*
 F6F7 3476            SETPAR  PSHS    U,Y,X,D
 F6F9 1E89                    EXG     A,B
 F6FB FDDFBF                  STD     PART2
 F6FE 1F10                    TFR     X,D
 F700 1E89                    EXG     A,B
 F702 FDDFBB                  STD     PART1
 F705 1F20                    TFR     Y,D
 F707 C40F                    ANDB    #$0F       ; mask off Hi nibble
 F709 8610                    LDA     #$10       ; shift into Hi nibble to
 F70B 3D                      MUL                ; form Lo field of length
 F70C F7DFBD                  STB     PART1+2
 F70F 1F20                    TFR     Y,D        ; recover length
 F711 44                      LSRA               ; shove the last 4 bits overboard
 F712 56                      RORB               ; (we have already dealt with these)
 F713 44                      LSRA
 F714 56                      RORB
 F715 44                      LSRA
 F716 56                      RORB
 F717 44                      LSRA
 F718 56                      RORB               ; use the remaining bits as
 F719 F7DFBE                  STB     PART1+3    ; Hi field of length
 F71C 1F30                    TFR     U,D        ; get Pt.2 length & treat as above
 F71E C40F                    ANDB    #$0F
 F720 8610                    LDA     #$10
 F722 3D                      MUL
 F723 F7DFC1                  STB     PART2+2
 F726 1F30                    TFR     U,D
 F728 44                      LSRA
 F729 56                      RORB
 F72A 44                      LSRA
 F72B 56                      RORB
 F72C 44                      LSRA
 F72D 56                      RORB
 F72E 44                      LSRA
 F72F 56                      RORB
 F730 F7DFC2                  STB     PART2+3
 F733 8D14                    BSR     VSYNC      ; wait for sync
 F735 8670                    LDA     #$70       ; 'pram' cmd.
 F737 17FF07                  LBSR    GCOM
 F73A 8EDFBB                  LDX     #PART1     ; transfer 8 params
 F73D C608                    LDB     #$08       ; from scratch to GDC
 F73F A680            SPRM2   LDA     ,X+
 F741 17FF0F                  LBSR    GPRM
 F744 5A                      DECB
 F745 26F8                    BNE     SPRM2
 F747 35F6                    PULS    PC,U,Y,X,D
                      ;*
                      ;* Sync to vertical blanking
                      ;*
 F749 3402            VSYNC   PSHS    A
 F74B B6FF14          VSYN2   LDA     GDC
 F74E 8520                    BITA    #$20
 F750 26F9                    BNE     VSYN2
 F752 B6FF14          VSYN3   LDA     GDC
 F755 8520                    BITA    #$20
 F757 27F9                    BEQ     VSYN3
 F759 3582                    PULS    PC,A
                      ;*
                      ;* Set graphics cursor
                      ;*
 F75B 3436            SETCRG  PSHS    Y,X,D
 F75D BFDFB7                  STX     XCOORD
 F760 10BFDFB9                STY     YCOORD
 F764 8649                    LDA     #$49       ; 'curs' cmd
 F766 17FED8                  LBSR    GCOM
 F769 1F20                    TFR     Y,D
 F76B 58                      ASLB               ; mult Y-coord by 48
 F76C 49                      ROLA               ; to yield number of
 F76D 58                      ASLB               ; words,(16 bit), in
 F76E 49                      ROLA               ; previous lines
 F76F 58                      ASLB
 F770 49                      ROLA
 F771 58                      ASLB
 F772 49                      ROLA
 F773 1F02                    TFR     D,Y
 F775 58                      ASLB
 F776 49                      ROLA
 F777 31AB                    LEAY    D,Y
 F779 1F10                    TFR     X,D
 F77B 44                      LSRA               ; divide X-coord by 16
 F77C 56                      RORB               ; to yield number of
 F77D 44                      LSRA               ; complete words on
 F77E 56                      RORB               ; this line.Add addr
 F77F 44                      LSRA               ; of 1st word in
 F780 56                      RORB               ; Partition,to get
 F781 44                      LSRA               ; addr of current word
 F782 56                      RORB
 F783 31AB                    LEAY    D,Y
 F785 31A95E00                LEAY    $5E00,Y
 F789 58                      ASLB               ; recover X-coord but
 F78A 49                      ROLA               ; with l.s. nibble
 F78B 58                      ASLB               ; set to 0. Subtract
 F78C 49                      ROLA               ; to yield number of
 F78D 58                      ASLB               ; bits in current word
 F78E 49                      ROLA
 F78F 58                      ASLB
 F790 49                      ROLA
 F791 43                      COMA
 F792 53                      COMB
 F793 C30001                  ADDD    #$0001
 F796 308B                    LEAX    D,X
 F798 1F20                    TFR     Y,D        ; format to suit GDC
 F79A 1E89                    EXG     A,B        ; parameter ram and
 F79C 17FEB4                  LBSR    GPRM       ; load parameters
 F79F 1E89                    EXG     A,B
 F7A1 17FEAF                  LBSR    GPRM
 F7A4 1F10                    TFR     X,D
 F7A6 8610                    LDA     #$10
 F7A8 3D                      MUL
 F7A9 C4F0                    ANDB    #$F0
 F7AB 1F98                    TFR     B,A
 F7AD 17FEA3                  LBSR    GPRM
 F7B0 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Get graphics cursor
                      ;*
 F7B2 3406            GETCRG  PSHS    D
 F7B4 86E0                    LDA     #$E0       ; 'curd' cmd
 F7B6 17FE88                  LBSR    GCOM
 F7B9 17FEA6                  LBSR    GPRMI      ; get cursor word adr
 F7BC 1F89                    TFR     A,B
 F7BE 17FEA1                  LBSR    GPRMI
 F7C1 108E0000                LDY     #$0000     ; zero line count
 F7C5 835E00                  SUBD    #$5E00     ; convert to word #
 F7C8 830030          GCRG1   SUBD    #$0030     ; count lines
 F7CB 2B04                    BMI     GCRG2
 F7CD 3121                    LEAY    $01,Y
 F7CF 20F7                    BRA     GCRG1
 F7D1 C30030          GCRG2   ADDD    #$0030
 F7D4 58                      ASLB               ; convert 'words on
 F7D5 49                      ROLA               ; current line' to
 F7D6 58                      ASLB               ; 'bits on current line'
 F7D7 49                      ROLA
 F7D8 58                      ASLB
 F7D9 49                      ROLA
 F7DA 58                      ASLB
 F7DB 49                      ROLA
 F7DC 1F01                    TFR     D,X        ; save in X
 F7DE 17FE81                  LBSR    GPRMI      ; Hi adr.bits.Discard
 F7E1 17FE7E                  LBSR    GPRMI      ; get dot addr
 F7E4 1F89                    TFR     A,B        ; (in 1 of 16 form)
 F7E6 17FE79                  LBSR    GPRMI
 F7E9 1CFE                    ANDCC   #$FE       ; clear carry
 F7EB 44              GCRG3   LSRA               ; count buckshee bits and
 F7EC 56                      RORB               ; increment X accordingly
 F7ED 2504                    BCS     GCRG4
 F7EF 3001                    LEAX    $01,X
 F7F1 20F8                    BRA     GCRG3
 F7F3 BFDFB7          GCRG4   STX     XCOORD     ; store coordinates
 F7F6 10BFDFB9                STY     YCOORD
 F7FA 3586                    PULS    PC,D
                      ;*
                      ;* Turn display off
                      ;*
 F7FC 3402            OFF     PSHS    A
 F7FE BDF749                  JSR     VSYNC
 F801 860C                    LDA     #$0C
 F803 17FE3B                  LBSR    GCOM
 F806 3582                    PULS    PC,A
                      ;*
                      ;* Turn display on
                      ;*
 F808 3402            ON      PSHS    A
 F80A BDF749                  JSR     VSYNC
 F80D 860D                    LDA     #$0D
 F80F 17FE2F                  LBSR    GCOM
 F812 3582                    PULS    PC,A
                      ;*
                      ;* Set display to graphics
                      ;*
 F814 3476            GRAPH   PSHS    U,Y,X,D
 F816 5F                      CLRB
 F817 8D16                    BSR     MODE
 F819 8A09                    ORA     #$09
 F81B 5A                      DECB
 F81C 8D11                    BSR     MODE       ; set interlaced
 F81E 8E5E00                  LDX     #$5E00     ; set Partitions
 F821 108E0240                LDY     #$0240
 F825 CC0000                  LDD     #$0000
 F828 1F03                    TFR     D,U
 F82A BDF6F7                  JSR     SETPAR
 F82D 35F6                    PULS    PC,U,Y,X,D
                      ;*
                      ;* Set GDC mode
                      ;*
 F82F 5D              MODE    TSTB
 F830 2710                    BEQ     MODE1
 F832 B7DFCB                  STA     GMODE
 F835 3402                    PSHS    A
 F837 860F                    LDA     #$0F       ; 'sync' mode
 F839 17FE05                  LBSR    GCOM
 F83C 3502                    PULS    A
 F83E 17FE12                  LBSR    GPRM
 F841 39                      RTS
 F842 B6DFCB          MODE1   LDA     GMODE
 F845 39                      RTS
                      ;*
                      ;* Set zoom factor
                      ;*
 F846 5D              ZOOM    TSTB
 F847 2710                    BEQ     ZOOM1
 F849 B7DFCC                  STA     GZOOM
 F84C 3402                    PSHS    A
 F84E 8646                    LDA     #$46       ; 'zoom'command
 F850 17FDEE                  LBSR    GCOM
 F853 3502                    PULS    A
 F855 17FDFB                  LBSR    GPRM
 F858 39                      RTS
 F859 B6DFCC          ZOOM1   LDA     GZOOM
 F85C 39                      RTS
                      ;*
                      ;* Area fill (On entry, A holds init dir)
                      ;*
 F85D 3436            FILL    PSHS    Y,X,D
 F85F 8487                    ANDA    #$87       ; set 'figs' P1 for graphics char
 F861 8A10                    ORA     #$10
 F863 B7DFCD                  STA     GFIGS
 F866 313F                    LEAY    -$01,Y     ; DN=(No.of pixels at
 F868 1F20                    TFR     Y,D        ; Rt.Angles to initial
 F86A FDDFCE                  STD     DN         ; direction - 1)
 F86D 1F10                    TFR     X,D        ; D0 & D2=(No.of pixels
 F86F FDDFD0                  STD     D0         ; in initial direction)
 F872 FDDFD2                  STD     D2
 F875 C607                    LDB     #$07       ; load 7 bytes from
 F877 17FE54                  LBSR    FIGSG      ; scratch,then draw
 F87A 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Clear graphics display
                      ;*
 F87C 3436            CLEAR   PSHS    Y,X,D
 F87E 8E0000                  LDX     #$0000     ; set cursor 0,0
 F881 1F12                    TFR     X,Y
 F883 BDF75B                  JSR     SETCRG
 F886 8E4000                  LDX     #$4000     ; (DN max=$3FFF)
 F889 8602                    LDA     #$02       ; pen type 'reset'
 F88B 8D11                    BSR     CLEARX     ; clear this block
 F88D 8E2C30                  LDX     #$2C30     ; now do rest
 F890 8602                    LDA     #$02
 F892 8D0A                    BSR     CLEARX
 F894 8E0000                  LDX     #$0000     ; and reset cursor to 0,0
 F897 1F12                    TFR     X,Y
 F899 BDF75B                  JSR     SETCRG
 F89C 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Clear (Xreg) words of display memory
                      ;*
 F89E 3412            CLEARX  PSHS    X,A
 F8A0 3402                    PSHS    A
 F8A2 301F                    LEAX    -$01,X     ; (DN=W-1)
 F8A4 3410                    PSHS    X
 F8A6 8EFFFF                  LDX     #$FFFF     ; enable all bits
 F8A9 BDF66D                  JSR     MASK
 F8AC 864C                    LDA     #$4C       ; 'figs' command
 F8AE 17FD90                  LBSR    GCOM
 F8B1 8602                    LDA     #$02       ; P1.wdata mode,dir 2
 F8B3 17FD9D                  LBSR    GPRM
 F8B6 3506                    PULS    D
 F8B8 1E89                    EXG     A,B
 F8BA 17FD96                  LBSR    GPRM       ; P2.DN-low
 F8BD 1E89                    EXG     A,B
 F8BF 17FD91                  LBSR    GPRM       ; P3.DN-hi
 F8C2 3502                    PULS    A          ; (pen type 02)
 F8C4 8A20                    ORA     #$20       ; 'wdat' command
 F8C6 17FD78                  LBSR    GCOM
 F8C9 86FF                    LDA     #$FF
 F8CB 17FD85                  LBSR    GPRM       ; data word all 1's
 F8CE 17FD82                  LBSR    GPRM
 F8D1 3592                    PULS    PC,X,A
                      ;*
                      ;* Initialise GDC
                      ;*
 F8D3 3416            GDCINI  PSHS    X,D
 F8D5 4F                      CLRA
 F8D6 17FD68                  LBSR    GCOM       ; 'reset' command
 F8D9 C621                    LDB     #$21
 F8DB BDF5EA          GDCI2   JSR     GETRTC     ; Load parameter ram from RTC
 F8DE BDF653                  JSR     GPRM
 F8E1 5C                      INCB
 F8E2 C129                    CMPB    #$29
 F8E4 26F5                    BNE     GDCI2
 F8E6 866F                    LDA     #$6F       ; 'vsync' command
 F8E8 17FD56                  LBSR    GCOM
 F8EB 8647                    LDA     #$47       ; 'pitch' command
 F8ED 17FD51                  LBSR    GCOM
 F8F0 8630                    LDA     #$30
 F8F2 17FD5E                  LBSR    GPRM
 F8F5 864B                    LDA     #$4B       ; 'cchar' command
 F8F7 17FD47                  LBSR    GCOM
 F8FA 4F                      CLRA
 F8FB 17FD55                  LBSR    GPRM
 F8FE 86C0                    LDA     #$C0
 F900 17FD50                  LBSR    GPRM
 F903 4F                      CLRA
 F904 17FD4C                  LBSR    GPRM
 F907 C601                    LDB     #$01
 F909 4F                      CLRA
 F90A 17FF39                  LBSR    ZOOM
 F90D 861F                    LDA     #$1F
 F90F B7DFCB                  STA     GMODE
 F912 866B                    LDA     #$6B       ; 'start' command
 F914 17FD2A                  LBSR    GCOM
 F917 BDFAC2                  JSR     CLEART
 F91A BDFAA4                  JSR     TEXT
 F91D 3596                    PULS    PC,X,D
                      ;*
                      ;* Plot a point
                      ;*
 F91F 3404            POINT   PSHS    B
 F921 7FDFCD                  CLR     GFIGS
 F924 C601                    LDB     #$01
 F926 17FD80                  LBSR    FIGSF
 F929 3584                    PULS    PC,B
                      ;*
                      ;* Plot a line
                      ;*
 F92B 3456            LINE    PSHS    U,X,D
 F92D CEF9A3                  LDU     #P1TBL     ; base adr.of P1 table
 F930 1F10                    TFR     X,D        ; calc X' (delta X)
 F932 B3DFB7                  SUBD    XCOORD
 F935 10830000                CMPD    #$0000
 F939 2E07                    BGT     LINE1      ; branch if X'>0
 F93B 3344                    LEAU    $04,U      ; else,reverse dir &
 F93D 43                      COMA               ; change sign of X'
 F93E 53                      COMB
 F93F C30001                  ADDD    #$0001
 F942 1F01            LINE1   TFR     D,X        ; X=|X'|
 F944 1F20                    TFR     Y,D        ; repeat for Y-axis
 F946 B3DFB9                  SUBD    YCOORD
 F949 10830000                CMPD    #$0000
 F94D 2E07                    BGT     LINE2
 F94F 3342                    LEAU    $02,U
 F951 43                      COMA
 F952 53                      COMB
 F953 C30001                  ADDD    #$0001
 F956 FDDF94          LINE2   STD     YTEMP
 F959 BFDF92                  STX     XTEMP
 F95C BCDF94                  CMPX    YTEMP
 F95F 2E08                    BGT     LINE3
 F961 3341                    LEAU    $01,U
 F963 BFDF94                  STX     YTEMP
 F966 FDDF92                  STD     XTEMP
                      ;* At this point,XTEMP=delta large,YTEMP=delta small
 F969 A6C4            LINE3   LDA     ,U         ; get P1
 F96B B7DFCD                  STA     GFIGS      ; put it in scratch
 F96E FCDF94                  LDD     YTEMP      ; calc ---
 F971 B3DF92                  SUBD    XTEMP      ; 2(delta min - delta max)
 F974 58                      ASLB
 F975 49                      ROLA
 F976 843F                    ANDA    #$3F       ; NOT > 63
 F978 FDDFD2                  STD     D2         ; store it
 F97B FCDF94                  LDD     YTEMP
 F97E 58                      ASLB
 F97F 49                      ROLA
 F980 FDDFD4                  STD     D4         ; = 2(delta min)
 F983 B3DF92                  SUBD    XTEMP      ; 2xdelta min-delta max
 F986 843F                    ANDA    #$3F       ; NOT > 63
 F988 FDDFD0                  STD     D0         ; store it
 F98B FCDF92                  LDD     XTEMP
 F98E FDDFCE                  STD     DN         ; = delta max
 F991 C609                    LDB     #$09       ; load 9 params & draw line
 F993 17FD13                  LBSR    FIGSF
 F996 3556                    PULS    U,X,D
 F998 BFDFB7                  STX     XCOORD     ; recover new coordinates
 F99B 10BFDFB9                STY     YCOORD     ; and update cursor
 F99F 17FDB9                  LBSR    SETCRG
 F9A2 39                      RTS
                      ;*
                      ;* 'figs' P1 table. (Select initial direction)
                      ;*                1   0   2   3   6   7   5   4
 F9A3 09080A0B0E0F0D  P1TBL   FCB     $09,$08,$0A,$0B,$0E,$0F,$0D,$0C
 F9AA 0C
                      ;*
                      ;* Plot a rectangle
                      ;*
 F9AB 3436            RECT    PSHS    Y,X,D
 F9AD 8407                    ANDA    #$07       ; init.dir. (7 max)
 F9AF 8A40                    ORA     #$40       ; set 'rectangle' bit
 F9B1 B7DFCD                  STA     GFIGS      ; store as P1 for 'figs'
 F9B4 CC0003                  LDD     #$0003     ; sides - 1
 F9B7 FDDFCE                  STD     DN
 F9BA 301F                    LEAX    -$01,X
 F9BC 313F                    LEAY    -$01,Y
 F9BE 1F10                    TFR     X,D        ; pix.in init dir. -1
 F9C0 FDDFD0                  STD     D0
 F9C3 FDDFD6                  STD     DM
 F9C6 1F20                    TFR     Y,D        ; pix at Rt.A -1
 F9C8 FDDFD2                  STD     D2
 F9CB CCFFFF                  LDD     #$FFFF     ; (-1)
 F9CE FDDFD4                  STD     D4
 F9D1 C60B                    LDB     #$0B       ; load 11 params & draw rectangle
 F9D3 17FCD3                  LBSR    FIGSF
 F9D6 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Plot a circle
                      ;*
 F9D8 3436            CIRCLE  PSHS    Y,X,D
 F9DA BEDFB7                  LDX     XCOORD     ; get coordinates of
 F9DD 10BEDFB9                LDY     YCOORD     ; centre point
 F9E1 BFDF92                  STX     XTEMP      ; save them
 F9E4 10BFDF94                STY     YTEMP
 F9E8 3086                    LEAX    A,X        ; add rad to X-coord
 F9EA C604                    LDB     #$04       ; dir = 4
 F9EC 8D3B                    BSR     ARC        ; 0-45 degrees
 F9EE C607                    LDB     #$07       ; dir = 7
 F9F0 8D37                    BSR     ARC        ; 0-315 degrees
 F9F2 BEDF92                  LDX     XTEMP      ; set X-coord to centre
 F9F5 31A6                    LEAY    A,Y        ; add rad to Y-coord
 F9F7 C602                    LDB     #$02       ; dir = 2
 F9F9 8D2E                    BSR     ARC        ; 270-315 degrees
 F9FB C605                    LDB     #$05       ; dir = 5
 F9FD 8D2A                    BSR     ARC        ; 270-225 degrees
 F9FF 10BEDF94                LDY     YTEMP      ; set Y-coord to centre
 FA03 40                      NEGA
 FA04 3086                    LEAX    A,X        ; sub rad from X-coord
 FA06 40                      NEGA
 FA07 5F                      CLRB
 FA08 8D1F                    BSR     ARC        ; 180-225 degrees
 FA0A C603                    LDB     #$03       ; dir = 3
 FA0C 8D1B                    BSR     ARC        ; 180-135 degrees
 FA0E BEDF92                  LDX     XTEMP      ; set X-coord to centre
 FA11 40                      NEGA
 FA12 31A6                    LEAY    A,Y        ; sub rad from Y-coord
 FA14 40                      NEGA
 FA15 C601                    LDB     #$01       ; dir = 1
 FA17 8D10                    BSR     ARC        ; 90-45 degrees
 FA19 C606                    LDB     #$06       ; dir = 6
 FA1B 8D0C                    BSR     ARC        ; 90-135 degrees
 FA1D BEDF92                  LDX     XTEMP      ; recover coordinates
 FA20 10BEDF94                LDY     YTEMP      ; of centre point &
 FA24 17FD34                  LBSR    SETCRG     ; set cursor
 FA27 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Plot an arc (on entry, A = radius, B = initial direction)
                      ;*
 FA29 3406            ARC     PSHS    D
 FA2B 17FD2D                  LBSR    SETCRG
 FA2E 3406                    PSHS    D
 FA30 C6B5                    LDB     #$B5       ; (0.707 X 256)
 FA32 3D                      MUL
 FA33 B7DFD8                  STA     CONST      ; 256(R X 0.707).[Hi byte]
 FA36 3506                    PULS    D
 FA38 C407                    ANDB    #$07       ; dir not > 7
 FA3A CA20                    ORB     #$20       ; set 'arc' mode
 FA3C F7DFCD                  STB     GFIGS
 FA3F 4A                      DECA               ; radius - 1
 FA40 5F                      CLRB
 FA41 B7DFD1                  STA     D1         ; Lo-byte of D = rad-1
 FA44 F7DFD0                  STB     D0         ; Hi-byte of D = 0
 FA47 1E89                    EXG     A,B
 FA49 58                      ASLB
 FA4A 49                      ROLA
 FA4B FDDFD2                  STD     D2         ; = 2(radius - 1)
 FA4E F6DFD8                  LDB     CONST
 FA51 4F                      CLRA
 FA52 FDDFCE                  STD     DN         ; = R x 0.707
 FA55 CCFFFF                  LDD     #$FFFF
 FA58 FDDFD4                  STD     D4         ; = -1
 FA5B CC0000                  LDD     #$0000
 FA5E FDDFD6                  STD     DM
 FA61 C60B                    LDB     #$0B       ; load 11 params & draw arc
 FA63 17FC43                  LBSR    FIGSF
 FA66 3586                    PULS    PC,D
                      ;*
                      ;* Set text cursor
                      ;*
 FA68 3416            SETCRT  PSHS    X,D
 FA6A BFDFE5                  STX     CURSOR
 FA6D 8649                    LDA     #$49       ; 'curs' command
 FA6F 17FBCF                  LBSR    GCOM
 FA72 1F10                    TFR     X,D
 FA74 1E89                    EXG     A,B
 FA76 17FBDA                  LBSR    GPRM       ; P1/2=cursor word
 FA79 1E89                    EXG     A,B        ; adr. Lo/Hi
 FA7B 17FBD5                  LBSR    GPRM
 FA7E 8608                    LDA     #$08
 FA80 17FBD0                  LBSR    GPRM
 FA83 3596                    PULS    PC,X,D
                      ;*
                      ;* Get text cursor
                      ;*
 FA85 3406            GETCRT  PSHS    D
 FA87 86E0                    LDA     #$E0       ; 'curd' command
 FA89 17FBB5                  LBSR    GCOM
 FA8C 17FBD3                  LBSR    GPRMI      ; P1=word adr. Lo
 FA8F 1F89                    TFR     A,B
 FA91 17FBCE                  LBSR    GPRMI      ; P2=word adr. Hi
 FA94 1F01                    TFR     D,X
 FA96 BFDFE5                  STX     CURSOR     ; curs.word adr
 FA99 17FBC6                  LBSR    GPRMI      ; P3=adr.Hi(not used)
 FA9C 17FBC3                  LBSR    GPRMI      ; P4/5=dot adr.Lo/Hi not
 FA9F 17FBC0                  LBSR    GPRMI      ; used in text mode,discard
 FAA2 3586                    PULS    PC,D
                      ;*
                      ;* Set display to text
                      ;*
 FAA4 3476            TEXT    PSHS    U,Y,X,D
 FAA6 5F                      CLRB
 FAA7 17FD85                  LBSR    MODE       ; get mode
 FAAA 84F6                    ANDA    #$F6
 FAAC 5C                      INCB
 FAAD 17FD7F                  LBSR    MODE       ; set noninterlaced
 FAB0 BEDFEC                  LDX     TS1        ; get text
 FAB3 FCDFEE                  LDD     TS2        ; Partition params
 FAB6 10BEDFF0                LDY     TL1
 FABA FEDFF2                  LDU     TL2
 FABD BDF6F7                  JSR     SETPAR     ; load them
 FAC0 35F6                    PULS    PC,U,Y,X,D
                      ;*
                      ;* Clear text display (Partition data in scratch ram)
                      ;*
 FAC2 3416            CLEART  PSHS    X,D
 FAC4 8ECA00                  LDX     #TXTRAM    ; point to text ram
 FAC7 8D9F                    BSR     SETCRT
 FAC9 8E3600                  LDX     #$3600     ; 288 lines X 48 words
 FACC 8602                    LDA     #$02
 FACE BDF89E                  JSR     CLEARX     ; clear text
 FAD1 8D1F                    BSR     INITXT     ; setup initial text
 FAD3 7FDFDA                  CLR     COL        ; home cursor
 FAD6 7FDFD9                  CLR     ROW
 FAD9 7FDFEB                  CLR     ESCFLG
 FADC 8601                    LDA     #$01
 FADE B7DFEA                  STA     CTYPE      ; solid cursor
 FAE1 8604                    LDA     #$04
 FAE3 B7DFE1                  STA     ATTRI
 FAE6 8DBC                    BSR     TEXT       ; set text mode
 FAE8 7DDFFF                  TST     BLANKD     ; cursor blanked ?
 FAEB 2702                    BEQ     CLTXT      ; no,skip
 FAED 8D5B                    BSR     FLCUR      ; yes,toggle it
 FAEF 3596            CLTXT   PULS    PC,X,D
 FAF1 39              CLINK   RTS                ; link text parameters
                      ;*
                      ;* Init text mode Partitions
                      ;*
 FAF2 8ECA00          INITXT  LDX     #TXTRAM    ; initialise text mode
 FAF5 1F10                    TFR     X,D        ; Partition parameters
 FAF7 108E0120                LDY     #$0120
 FAFB CE0000                  LDU     #$0000
 FAFE BFDFEC          UPDPA   STX     TS1        ; update Partitions
 FB01 FDDFEE                  STD     TS2
 FB04 10BFDFF0                STY     TL1
 FB08 FFDFF2                  STU     TL2
 FB0B 3402                    PSHS    A
 FB0D B6DFCB                  LDA     GMODE
 FB10 8509                    BITA    #$09       ; if text mode set
 FB12 2702                    BEQ     ITRET      ; load these params
 FB14 3582                    PULS    PC,A       ; else,return
 FB16 3502            ITRET   PULS    A
 FB18 BDF6F7                  JSR     SETPAR
 FB1B 39                      RTS
                      ;*
                      ;* Send a char to video
                      ;*
 FB1C 3476            VIDCH   PSHS    U,Y,X,D
 FB1E BDF341                  JSR     FAST
 FB21 7DDFFF                  TST     BLANKD     ; cursor blanked ?
 FB24 2702                    BEQ     VIDC1      ; if so,
 FB26 8D22                    BSR     FLCUR      ; toggle it
 FB28 7DDFEB          VIDC1   TST     ESCFLG     ; set ?
 FB2B 2705                    BEQ     VIDC2      ; no, continue
 FB2D BDFC6A                  JSR     CMOVE      ; else, deal with it
 FB30 2013                    BRA     VIDC3      ; and exit
 FB32 8120            VIDC2   CMPA    #$20       ; is it a control chr ?
 FB34 257F                    BCS     VIDCC      ; yes,go do it
 FB36 847F                    ANDA    #$7F       ; else,make sure its
 FB38 8D29                    BSR     GPCHR      ; ascii & do it
 FB3A B6DFDA                  LDA     COL
 FB3D 4C                      INCA
 FB3E 816C                    CMPA    #$6C       ; end of line ?
 FB40 2703                    BEQ     VIDC3      ; yes,exit
 FB42 B7DFDA                  STA     COL        ; no,update col
 FB45 BDF34E          VIDC3   JSR     SLOW
 FB48 35F6                    PULS    PC,U,Y,X,D
                      ;*
                      ;* Flashing cursor
                      ;*
 FB4A 3476            FLCUR   PSHS    U,Y,X,D
 FB4C 7DDFEA                  TST     CTYPE
 FB4F 2B10                    BMI     FLC2       ; cursor off,skip
 FB51 8601                    LDA     #$01       ; (complement mode)
 FB53 BDF67F                  JSR     SETPEN
 FB56 B6DFEA                  LDA     CTYPE
 FB59 8A80                    ORA     #$80       ; adjust for use as index
 FB5B 4A                      DECA               ; to char table
 FB5C 8D0D                    BSR     GPCH2      ; toggle cursor
 FB5E 73DFFF                  COM     BLANKD     ; toggle 'blanked' flag
 FB61 35F6            FLC2    PULS    PC,U,Y,X,D
                      ;*
                      ;* Deal with printable character. (7 bit ascii in ACCA)
                      ;*
 FB63 3406            GPCHR   PSHS    D
 FB65 4F                      CLRA               ; (replace mode)
 FB66 BDF67F                  JSR     SETPEN
 FB69 3506                    PULS    D          ; peek & put back
 FB6B 3406            GPCH2   PSHS    D
 FB6D 8D1C                    BSR     CCT2G      ; adjust coordinates
 FB6F 8020                    SUBA    #$20       ; use as index
 FB71 8EFD01                  LDX     #CSETB     ; (char set,Normal)
 FB74 C605                    LDB     #$05       ; find character
 FB76 3D                      MUL
 FB77 308B                    LEAX    D,X
 FB79 BDF696                  JSR     SETPAT     ; set it up
 FB7C B6DFE1                  LDA     ATTRI
 FB7F 108E0005                LDY     #$0005     ; pixels in init dir
 FB83 8E0008                  LDX     #$0008     ; pixels at Rt.Angles
 FB86 BDF85D                  JSR     FILL       ; and print it
 FB89 3586                    PULS    PC,D
                      ;*
                      ;* Convert coordinates,text to graphic
                      ;*
 FB8B 3436            CCT2G   PSHS    Y,X,D
 FB8D B6DFD9                  LDA     ROW        ; row No
 FB90 C60C                    LDB     #$0C       ; lines per row
 FB92 3D                      MUL
 FB93 F3DFF2                  ADDD    TL2        ; + overwritten lines
 FB96 1F02                    TFR     D,Y
 FB98 108C0120                CMPY    #$0120     ; 2nd time round ?
 FB9C 2D04                    BLT     CCT2       ; no,skip
 FB9E 31A9FEE0                LEAY    $FEE0,Y    ; yes,-len of T ram
 FBA2 31A90248        CCT2    LEAY    $0248,Y    ; +len of G ram
 FBA6 B6DFDA                  LDA     COL
 FBA9 C607                    LDB     #$07       ; (width of box col)
 FBAB 3D                      MUL
 FBAC 1F01                    TFR     D,X
 FBAE 300C                    LEAX    $0C,X      ; +initial offset
 FBB0 BDF75B                  JSR     SETCRG
 FBB3 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Deal with control character (entered from send chr to video)
                      ;*
 FBB5 3416            VIDCC   PSHS    X,D
 FBB7 8EFBC1                  LDX     #TCCACT
 FBBA 48                      ASLA               ; char X 2 is used
 FBBB AD96                    JSR     [A,X]      ; as index to table
 FBBD 3516                    PULS    X,D
 FBBF 2084                    BRA     VIDC3      ; return to sender
                      ;*
                      ;* Table of control code action routines
                      ;*
 FBC1 FC27            TCCACT  FDB     IGNORE
 FBC3 FC27                    FDB     IGNORE
 FBC5 FC27                    FDB     IGNORE
 FBC7 FC27                    FDB     IGNORE
 FBC9 FC27                    FDB     IGNORE
 FBCB FC27                    FDB     IGNORE
 FBCD FC27                    FDB     IGNORE
 FBCF F61D                    FDB     BEEP       ; bell
 FBD1 FC01                    FDB     CLEFT      ; cursor left
 FBD3 FC0B                    FDB     CRIGHT     ; cursor right
 FBD5 FC17                    FDB     CDOWN      ; cursor down
 FBD7 FC28                    FDB     CUP        ; cursor up
 FBD9 FAC2                    FDB     CLEART     ; clear screen
 FBDB FC36                    FDB     CCR        ; CR
 FBDD FC6A                    FDB     CMOVE      ; cursor move
 FBDF FC33                    FDB     CHOME      ; cursor home
 FBE1 F808                    FDB     ON         ; screen on
 FBE3 F7FC                    FDB     OFF        ; screen off
 FBE5 FC43                    FDB     CURON      ; cursor on
 FBE7 FC3A                    FDB     CUROFF     ; cursor off
 FBE9 FC4C                    FDB     CURSOL     ; cursor solid
 FBEB FC52                    FDB     CURBOX     ; cursor box
 FBED FC58                    FDB     ATTON      ; attributes on
 FBEF FC61                    FDB     ATTOFF     ; attributes off
 FBF1 FC27                    FDB     IGNORE     ; (clear to end of line)
 FBF3 FC27                    FDB     IGNORE     ; (clear to end of screen)
 FBF5 FCD6                    FDB     CLINE      ; clear line
 FBF7 FC27                    FDB     IGNORE
 FBF9 FC27                    FDB     IGNORE
 FBFB FC27                    FDB     IGNORE
 FBFD FC27                    FDB     IGNORE
 FBFF FC27                    FDB     IGNORE
                      ;*
                      ;* Action routines for control char
                      ;*
                      ;* Cursor left
 FC01 B6DFDA          CLEFT   LDA     COL
 FC04 4A                      DECA
 FC05 2B03                    BMI     CLEF1      ; if fully left, ignore
 FC07 B7DFDA                  STA     COL
 FC0A 39              CLEF1   RTS
                      ;* Cursor right
 FC0B B6DFDA          CRIGHT  LDA     COL
 FC0E 4C                      INCA
 FC0F 816C                    CMPA    #$6C       ; if fully right, ignore
 FC11 2703                    BEQ     CRIG1
 FC13 B7DFDA                  STA     COL
 FC16 39              CRIG1   RTS
                      ;* Cursor down
 FC17 B6DFD9          CDOWN   LDA     ROW
 FC1A 4C                      INCA
 FC1B 8118                    CMPA    #$18       ; 24? (N.B. rows=0-23)
 FC1D 2605                    BNE     CRET
 FC1F 8D6B                    BSR     SCRUP      ; scroll up
 FC21 7EFCD6                  JMP     CLINE      ; clear line.(Btm)
 FC24 B7DFD9          CRET    STA     ROW
                      ;* Control char ignored
 FC27 39              IGNORE  RTS                ; no action
                      ;* Cursor up
 FC28 B6DFD9          CUP     LDA     ROW
 FC2B 4A                      DECA
 FC2C 2AF6                    BPL     CRET
 FC2E 8D79                    BSR     SCRDWN     ; scroll down
 FC30 7EFCD6                  JMP     CLINE      ; clear line.(Top)
                      ;* Cursor home (top-left)
 FC33 7FDFD9          CHOME   CLR     ROW
                      ;* CR (cursor begin of line)
 FC36 7FDFDA          CCR     CLR     COL
 FC39 39                      RTS
                      ;* Cursor off
 FC3A B6DFEA          CUROFF  LDA     CTYPE
 FC3D 8A80                    ORA     #$80
 FC3F B7DFEA                  STA     CTYPE
 FC42 39                      RTS
                      ;* Cursor on
 FC43 B6DFEA          CURON   LDA     CTYPE
 FC46 847F                    ANDA    #$7F
 FC48 B7DFEA                  STA     CTYPE
 FC4B 39                      RTS
                      ;* Solid cursor
 FC4C 8601            CURSOL  LDA     #$01
 FC4E B7DFEA                  STA     CTYPE
 FC51 39                      RTS
                      ;* Box cursor
 FC52 8602            CURBOX  LDA     #$02
 FC54 B7DFEA                  STA     CTYPE
 FC57 39                      RTS
                      ;* Attributes on
 FC58 B6DFE1          ATTON   LDA     ATTRI
 FC5B 8A81                    ORA     #$81
 FC5D B7DFE1                  STA     ATTRI
 FC60 39                      RTS
                      ;* Attributes off
 FC61 B6DFE1          ATTOFF  LDA     ATTRI
 FC64 847E                    ANDA    #$7E
 FC66 B7DFE1                  STA     ATTRI
 FC69 39                      RTS
                      ;*
                      ;* Move cursor (3 pass escape sequence)
                      ;*
 FC6A F6DFEB          CMOVE   LDB     ESCFLG
 FC6D 5D                      TSTB               ; is it set ?
 FC6E 2606                    BNE     CMOV1      ; yes,branch
 FC70 C602                    LDB     #$02       ; no,set it
 FC72 F7DFEB                  STB     ESCFLG
 FC75 39                      RTS
 FC76 C102            CMOV1   CMPB    #$02       ; is it 2 ?
 FC78 2609                    BNE     CMOV2      ; no,branch
 FC7A 8020                    SUBA    #$20       ; yes,update row
 FC7C B7DFD9                  STA     ROW
 FC7F 7ADFEB                  DEC     ESCFLG
 FC82 39                      RTS
 FC83 8020            CMOV2   SUBA    #$20       ; update col and
 FC85 B7DFDA                  STA     COL
 FC88 7ADFEB                  DEC     ESCFLG     ; clear flag
 FC8B 39                      RTS
                      ;*
                      ;* Scroll up
 FC8C 10BEDFF0        SCRUP   LDY     TL1        ; reduce TL1 by one row
 FC90 3134                    LEAY    -$0C,Y
 FC92 2603                    BNE     SCRUP1
 FC94 16FE5B                  LBRA    INITXT     ; init Part.params
 FC97 FCDFEE          SCRUP1  LDD     TS2
 FC9A BEDFEC                  LDX     TS1
 FC9D 30890240                LEAX    $0240,X    ; 12 lines X 48 words
 FCA1 FEDFF2                  LDU     TL2        ; (ie. advance 1 row)
 FCA4 334C                    LEAU    $0C,U      ; increment TL2 by one row
 FCA6 16FE55                  LBRA    UPDPA      ; update Part.params
                      ;*
                      ;* Scroll down
 FCA9 FEDFF2          SCRDWN  LDU     TL2        ; if zero,apply
 FCAC 2718                    BEQ     SCRD1      ; cooking factor
 FCAE BEDFEC                  LDX     TS1
 FCB1 3089FDC0                LEAX    -$0240,X   ; retreat one row
 FCB5 FCDFEE                  LDD     TS2
 FCB8 10BEDFF0                LDY     TL1        ; increase TL1 by one row
 FCBC 312C                    LEAY    $0C,Y
 FCBE FEDFF2                  LDU     TL2        ; reduce TL2 by one row
 FCC1 3354                    LEAU    -$0C,U
 FCC3 16FE38                  LBRA    UPDPA      ; update Part.params
 FCC6 8EFDC0          SCRD1   LDX     #$FDC0     ; TS1
 FCC9 CCCA00                  LDD     #TXTRAM    ; TS2
 FCCC 108E000C                LDY     #$000C     ; TL1 (1 row)
 FCD0 CE0114                  LDU     #$0114     ; TL2 (23 rows)
 FCD3 16FE28                  LBRA    UPDPA
                      ;*
                      ;* Clear line
 FCD6 3436            CLINE   PSHS    Y,X,D
 FCD8 FCDFD9                  LDD     ROW
 FCDB C60C                    LDB     #$0C       ; convert to lines
 FCDD 3D                      MUL
 FCDE F3DFF2                  ADDD    TL2        ; +overwritten lines
 FCE1 1F02                    TFR     D,Y
 FCE3 108C0120                CMPY    #$0120     ; 2nd time round ?
 FCE7 2D04                    BLT     CLIN1      ; skip if not
 FCE9 31A9FEE0                LEAY    $FEE0,Y    ; -len of text ram
 FCED 31A90240        CLIN1   LEAY    $0240,Y    ; +len of graphics ram
 FCF1 8E0000                  LDX     #$0000
 FCF4 BDF75B                  JSR     SETCRG     ; (to start of row)
 FCF7 8E0240                  LDX     #$0240     ; clear one row
 FCFA 8602                    LDA     #$02
 FCFC BDF89E                  JSR     CLEARX
 FCFF 35B6                    PULS    PC,Y,X,D
                      ;*
                      ;* Normal charset bitmap (graphic char as ASCII
                      ;* 7 bits stored as 5 columns x 8 bits images
                      ;*
 FD01 0000000000      CSETB   FCB     $00,$00,$00,$00,$00 ; space
 FD06 0000FA0000              FCB     $00,$00,$FA,$00,$00 ; !
 FD0B 00E000E000              FCB     $00,$E0,$00,$E0,$00 ; "
 FD10 50F850F850              FCB     $50,$F8,$50,$F8,$50 ; #
 FD15 4854FE5424              FCB     $48,$54,$FE,$54,$24 ; $
 FD1A 4626106864              FCB     $46,$26,$10,$68,$64 ; %
 FD1F 0A44AA926C              FCB     $0A,$44,$AA,$92,$6C ; &
 FD24 00E0D00000              FCB     $00,$E0,$D0,$00,$00 ; '
 FD29 0082443800              FCB     $00,$82,$44,$38,$00 ; (
 FD2E 0038448200              FCB     $00,$38,$44,$82,$00 ; )
 FD33 5438FE3854              FCB     $54,$38,$FE,$38,$54 ; *
 FD38 10107C1010              FCB     $10,$10,$7C,$10,$10 ; +
 FD3D 000E0D0000              FCB     $00,$0E,$0D,$00,$00 ; ,
 FD42 1010101010              FCB     $10,$10,$10,$10,$10 ; -
 FD47 0000060600              FCB     $00,$00,$06,$06,$00 ; .
 FD4C 4020100804              FCB     $40,$20,$10,$08,$04 ; /
 FD51 007C82827C              FCB     $00,$7C,$82,$82,$7C ; 0
 FD56 0000FE4000              FCB     $00,$00,$FE,$40,$00 ; 1
 FD5B 6292928A46              FCB     $62,$92,$92,$8A,$46 ; 2
 FD60 CCB2928282              FCB     $CC,$B2,$92,$82,$82 ; 3
 FD65 10FE1010F0              FCB     $10,$FE,$10,$10,$F0 ; 4
 FD6A 9CA2A2A2E2              FCB     $9C,$A2,$A2,$A2,$E2 ; 5
 FD6F 0C9292523C              FCB     $0C,$92,$92,$52,$3C ; 6
 FD74 C0A0908886              FCB     $C0,$A0,$90,$88,$86 ; 7
 FD79 6C9292926C              FCB     $6C,$92,$92,$92,$6C ; 8
 FD7E 7894929260              FCB     $78,$94,$92,$92,$60 ; 9
 FD83 00006C6C00              FCB     $00,$00,$6C,$6C,$00 ; :
 FD88 00006E6D00              FCB     $00,$00,$6E,$6D,$00 ; ;
 FD8D 0082442810              FCB     $00,$82,$44,$28,$10 ; <
 FD92 2828282828              FCB     $28,$28,$28,$28,$28 ; =
 FD97 1028448200              FCB     $10,$28,$44,$82,$00 ; >
 FD9C 60908A8040              FCB     $60,$90,$8A,$80,$40 ; ?
 FDA1 7AAABA827C              FCB     $7A,$AA,$BA,$82,$7C ; @
 FDA6 7E9090907E              FCB     $7E,$90,$90,$90,$7E ; A
 FDAB 6C929292FE              FCB     $6C,$92,$92,$92,$FE ; B
 FDB0 448282827C              FCB     $44,$82,$82,$82,$7C ; C
 FDB5 7C828282FE              FCB     $7C,$82,$82,$82,$FE ; D
 FDBA 82929292FE              FCB     $82,$92,$92,$92,$FE ; E
 FDBF 80909090FE              FCB     $80,$90,$90,$90,$FE ; F
 FDC4 5E9292827C              FCB     $5E,$92,$92,$82,$7C ; G
 FDC9 FE101010FE              FCB     $FE,$10,$10,$10,$FE ; H
 FDCE 0082FE8200              FCB     $00,$82,$FE,$82,$00 ; I
 FDD3 FC02020204              FCB     $FC,$02,$02,$02,$04 ; J
 FDD8 82442810FE              FCB     $82,$44,$28,$10,$FE ; K
 FDDD 02020202FE              FCB     $02,$02,$02,$02,$FE ; L
 FDE2 FE402040FE              FCB     $FE,$40,$20,$40,$FE ; M
 FDE7 FE102040FE              FCB     $FE,$10,$20,$40,$FE ; N
 FDEC 7C8282827C              FCB     $7C,$82,$82,$82,$7C ; O
 FDF1 60909090FE              FCB     $60,$90,$90,$90,$FE ; P
 FDF6 7A848A827C              FCB     $7A,$84,$8A,$82,$7C ; Q
 FDFB 62949890FE              FCB     $62,$94,$98,$90,$FE ; R
 FE00 4C92929264              FCB     $4C,$92,$92,$92,$64 ; S
 FE05 8080FE8080              FCB     $80,$80,$FE,$80,$80 ; T
 FE0A FC020202FC              FCB     $FC,$02,$02,$02,$FC ; U
 FE0F F8040204F8              FCB     $F8,$04,$02,$04,$F8 ; V
 FE14 FE041804FE              FCB     $FE,$04,$18,$04,$FE ; W
 FE19 C6281028C6              FCB     $C6,$28,$10,$28,$C6 ; X
 FE1E E0100E10E0              FCB     $E0,$10,$0E,$10,$E0 ; Y
 FE23 C2A2928A86              FCB     $C2,$A2,$92,$8A,$86 ; Z
 FE28 008282FE00              FCB     $00,$82,$82,$FE,$00 ; [
 FE2D 0408102040              FCB     $04,$08,$10,$20,$40 ; \
 FE32 00FE828200              FCB     $00,$FE,$82,$82,$00 ; ]
 FE37 2040FE4020              FCB     $20,$40,$FE,$40,$20 ; ^
 FE3C 0101010101              FCB     $01,$01,$01,$01,$01 ; _
 FE41 0000D0E000              FCB     $00,$00,$D0,$E0,$00 ; `
 FE46 021E2A2A0E              FCB     $02,$1E,$2A,$2A,$0E ; a
 FE4B 3C2222FE02              FCB     $3C,$22,$22,$FE,$02 ; b
 FE50 1222221C00              FCB     $12,$22,$22,$1C,$00 ; c
 FE55 02FE22221C              FCB     $02,$FE,$22,$22,$1C ; d
 FE5A 122A2A1C00              FCB     $12,$2A,$2A,$1C,$00 ; e
 FE5F 40503E1000              FCB     $40,$50,$3E,$10,$00 ; f
 FE64 3E25251900              FCB     $3E,$25,$25,$19,$00 ; g
 FE69 1E2020FE00              FCB     $1E,$20,$20,$FE,$00 ; h
 FE6E 00005E0000              FCB     $00,$00,$5E,$00,$00 ; i
 FE73 002E010200              FCB     $00,$2E,$01,$02,$00 ; j
 FE78 2214087E00              FCB     $22,$14,$08,$7E,$00 ; k
 FE7D 00027E4000              FCB     $00,$02,$7E,$40,$00 ; l
 FE82 1E203E203E              FCB     $1E,$20,$3E,$20,$3E ; m
 FE87 1E20203E00              FCB     $1E,$20,$20,$3E,$00 ; n
 FE8C 1C22221C00              FCB     $1C,$22,$22,$1C,$00 ; o
 FE91 1824243F00              FCB     $18,$24,$24,$3F,$00 ; p
 FE96 013F242418              FCB     $01,$3F,$24,$24,$18 ; q
 FE9B 2020103E00              FCB     $20,$20,$10,$3E,$00 ; r
 FEA0 242A2A1200              FCB     $24,$2A,$2A,$12,$00 ; s
 FEA5 04227C2000              FCB     $04,$22,$7C,$20,$00 ; t
 FEAA 023E02023C              FCB     $02,$3E,$02,$02,$3C ; u
 FEAF 300C020C30              FCB     $30,$0C,$02,$0C,$30 ; v
 FEB4 3C020C023C              FCB     $3C,$02,$0C,$02,$3C ; w
 FEB9 22121C2422              FCB     $22,$12,$1C,$24,$22 ; x
 FEBE 3F05043800              FCB     $3F,$05,$04,$38,$00 ; y
 FEC3 20322A2602              FCB     $20,$32,$2A,$26,$02 ; z
 FEC8 82826C1000              FCB     $82,$82,$6C,$10,$00 ; {
 FECD 0000EE0000              FCB     $00,$00,$EE,$00,$00 ; |
 FED2 106C828200              FCB     $10,$6C,$82,$82,$00 ; }
 FED7 1C10101010              FCB     $1C,$10,$10,$10,$10 ; ~
 FEDC AA55AA55AA              FCB     $AA,$55,$AA,$55,$AA ; chess pattern
 FEE1 FFFFFFFFFF              FCB     $FF,$FF,$FF,$FF,$FF ; bloc pattern
 FEE6 C3810081C3              FCB     $C3,$81,$00,$81,$C3 ; angle pattern
 FEEB F8FF29                  FCB     $F8,$FF,$29         ; void...
                      ;*
                      ;* SAM space : not used, except $FFF0-$FFFF (vectors)
                      ;* $FF60-$FFBF is readable too (boot ROM) but seems not used
                      ;*

                              ORG     $FF00

 FF00 FFBB                    FDB     $FFBB                    ;FF00: FF BB
 FF02 0216                    FDB     $0216                    ;FF02: 02 16
 FF04 FFB9                    FDB     $FFB9                    ;FF04: FF B9
 FF06 0216                    FDB     $0216                    ;FF06: 02 16
 FF08 FFB3                    FDB     $FFB3                    ;FF08: FF B3
 FF0A 0216                    FDB     $0216                    ;FF0A: 02 16
 FF0C FFBB                    FDB     $FFBB                    ;FF0C: FF BB
 FF0E 0216                    FDB     $0216                    ;FF0E: 02 16
 FF10 FFBB                    FDB     $FFBB                    ;FF10: FF BB
 FF12 0014                    FDB     $0014                    ;FF12: 00 14
 FF14 FFBB                    FDB     $FFBB                    ;FF14: FF BB
 FF16 0214                    FDB     $0214                    ;FF16: 02 14
 FF18 FFBB                    FDB     $FFBB                    ;FF18: FF BB
 FF1A 0216FFBB                FDB     $0216,$FFBB              ;FF1A: 02 16 FF BB
 FF1E 0014                    FDB     $0014                    ;FF1E: 00 14
 FF20 FFB90216FFBB00          FDB     $FFB9,$0216,$FFBB,$0016  ;FF20: FF B9 02 16 FF BB 00 16
 FF27 16
 FF28 FFB30212FFB302          FDB     $FFB3,$0212,$FFB3,$0216  ;FF28: FF B3 02 12 FF B3 02 16
 FF2F 16
 FF30 FFF30016FFBB00          FDB     $FFF3,$0016,$FFBB,$0014  ;FF30: FF F3 00 16 FF BB 00 14
 FF37 14
 FF38 FFB30014FFB300          FDB     $FFB3,$0014,$FFB3,$001C  ;FF38: FF B3 00 14 FF B3 00 1C
 FF3F 1C
 FF40 1000BFFF1000BF          FDB     $1000,$BFFF,$1000,$BFFF  ;FF40: 10 00 BF FF 10 00 BF FF
 FF47 FF
 FF48 1000BFFF1000BF          FDB     $1000,$BFFF,$1000,$BFFF  ;FF48: 10 00 BF FF 10 00 BF FF
 FF4F FF
 FF50 1000BFFF1000FF          FDB     $1000,$BFFF,$1000,$FFFF  ;FF50: 10 00 BF FF 10 00 FF FF
 FF57 FF
 FF58 1000BFFF1000FF          FDB     $1000,$BFFF,$1000,$FFFF  ;FF58: 10 00 BF FF 10 00 FF FF
 FF5F FF
 FF60 1000BFFF1000BF          FDB     $1000,$BFFF,$1000,$BFFF  ;FF60: 10 00 BF FF 10 00 BF FF
 FF67 FF
 FF68 1000FFFF1000BF          FDB     $1000,$FFFF,$1000,$BFFF  ;FF68: 10 00 FF FF 10 00 BF FF
 FF6F FF
 FF70 1000FFFF1000BF          FDB     $1000,$FFFF,$1000,$BFFF  ;FF70: 10 00 FF FF 10 00 BF FF
 FF77 FF
 FF78 1000BFFF1000FF          FDB     $1000,$BFFF,$1000,$FFFF  ;FF78: 10 00 BF FF 10 00 FF FF
 FF7F FF
 FF80 B9FF1400B8FF16          FDB     $B9FF,$1400,$B8FF,$1600  ;FF80: B9 FF 14 00 B8 FF 16 00
 FF87 00
 FF88 BBFF1600B9FD14          FDB     $BBFF,$1600,$B9FD,$1402  ;FF88: BB FF 16 00 B9 FD 14 02
 FF8F 02
 FF90 B9FF1600B1FD16          FDB     $B9FF,$1600,$B1FD,$1602  ;FF90: B9 FF 16 00 B1 FD 16 02
 FF97 02
 FF98 B9FF1600B9FD14          FDB     $B9FF,$1600,$B9FD,$1402  ;FF98: B9 FF 16 00 B9 FD 14 02
 FF9F 02
 FFA0 B1FF1600B9FD16          FDB     $B1FF,$1600,$B9FD,$1602  ;FFA0: B1 FF 16 00 B9 FD 16 02
 FFA7 02
 FFA8 BBFF1600B8FF16          FDB     $BBFF,$1600,$B8FF,$1602  ;FFA8: BB FF 16 00 B8 FF 16 02
 FFAF 02
 FFB0 B9FF1600B9FD16          FDB     $B9FF,$1600,$B9FD,$1602  ;FFB0: B9 FF 16 00 B9 FD 16 02
 FFB7 02
 FFB8 B9FF1600B9FD16          FDB     $B9FF,$1600,$B9FD,$1602  ;FFB8: B9 FF 16 00 B9 FD 16 02
 FFBF 02
 FFC0 0010FFBF0010FF          FDB     $0010,$FFBF,$0010,$FFBF  ;FFC0: 00 10 FF BF 00 10 FF BF
 FFC7 BF
 FFC8 0010FFBF0010FF          FDB     $0010,$FFBF,$0010,$FFBF  ;FFC8: 00 10 FF BF 00 10 FF BF
 FFCF BF
 FFD0 0010FFBF0010            FDB     $0010,$FFBF,$0010        ;FFD0: 00 10 FF BF 00 10
 FFD6 FFBF                    FDB     $FFBF                    ;FFD6: FF BF
 FFD8 0010                    FDB     $0010                    ;FFD8: 00 10
 FFDA FFBF                    FDB     $FFBF                    ;FFDA: FF BF
 FFDC 0010                    FDB     $0010                    ;FFDC: 00 10
 FFDE FFFF                    FDB     $FFFF                    ;FFDE: FF FF
 FFE0 0010FFBF0010FF          FDB     $0010,$FFBF,$0010,$FFBF  ;FFE0: 00 10 FF BF 00 10 FF BF
 FFE7 BF
 FFE8 0010FFBF0010FF          FDB     $0010,$FFBF,$0010,$FFBF  ;FFE8: 00 10 FF BF 00 10 FF BF
 FFEF BF
                      ;*
                      ;* Restart control vectors.
                      ;*
                                ORG (PROM+$1FF0)

 FFF0 F08E                      FDB      RESET               Not implemented in 6809.
 FFF2 F12C                      FDB      SWI3                Software interupt three.
 FFF4 F128                      FDB      SWI2                Software interupt two.
 FFF6 F124                      FDB      FIRQ                Fast interupt request.
 FFF8 F120                      FDB      IRQ                 Interupt request.
 FFFA E574                      FDB      SWI                 Software interupt.
 FFFC F11C                      FDB      NMI                 Non-maskable interupt.
 FFFE F08E            VCRST     FDB      RESET               Cold start.
                      ;*
                      ;*
                                END

SYMBOL TABLE
     ACIA1 00 FF08     ACIA2 00 FF04       ARC 02 FA29   ASCLOOP 02 E60B
    ATTOFF 02 FC61     ATTON 02 FC58     ATTRI 00 DFE1     BADDR 02 F55C
      BAUD 00 FF0C      BEEP 02 F61D        BF 02 EC1B    BLANKD 00 DFFF
        BO 02 E328       BO1 02 E340       BO2 02 E351       BO3 02 E357
       BO4 02 E36A       BO5 02 E374     BODIS 02 E320    BOFAIL 02 E37E
     BOFL1 02 E391     BOFL2 02 E3A1     BOFL3 02 E3B5     BOFL4 02 E3C2
     BOMES 02 E2FA    BSYBIT 00 0080    BUFFER 02 DE80      BYTE 02 F567
     CALD1 02 E478    CALDIS 02 E455       CCR 02 FC36      CCT2 02 FBA2
     CCT2G 02 FB8B        CD 02 E4A0       CD1 02 E4CB     CDOWN 02 FC17
     CFMST 02 E094     CFSLV 02 E0A7    CHKDRQ 02 F435    CHKDT2 02 F43E
    CHKRDY 02 F4E7    CHKVEC 02 DFAB     CHOME 02 FC33    CINCHN 00 D3E5
    CIRCLE 02 F9D8     CLEAR 02 F87C    CLEART 02 FAC2    CLEARX 02 F89E
     CLEF1 02 FC0A     CLEFT 02 FC01     CLIN1 02 FCED     CLINE 02 FCD6
     CLINK 02 FAF1    CLR_R0 00 FFD6    CLR_R1 00 FFD8     CLTXT 02 FAEF
   CMDWAIT 02 F3B6     CMOV1 02 FC76     CMOV2 02 FC83     CMOVE 02 FC6A
       COL 00 DFDA     COLDS 00 CD00    COMREG 00 FF10    COMTAB 02 E1FF
    CONPRS 02 E4DF     CONST 00 DFD8   CONTINI 02 E1F4    CONTRL 02 F0DF
        CP 02 E4F6     CPRTC 02 E40F      CRET 02 FC24     CRIG1 02 FC16
    CRIGHT 02 FC0B     CRLFS 02 F50F     CSETB 02 FD01     CTYPE 00 DFEA
       CUP 02 FC28    CURBOX 02 FC52    CURDRV 00 DFB6    CUROFF 02 FC3A
     CURON 02 FC43    CURSOL 02 FC4C    CURSOR 00 DFE5    CWLOOP 02 F3B8
        D0 00 DFD0        D1 00 DFD1        D2 00 DFD2        D4 00 DFD4
    DATREG 00 FF13   DATWAIT 02 F3C1        DC 02 EC3B     DCMES 02 EC24
      DDEN 02 F2E1    DDSTAB 02 DF9D     DELAY 02 F542    DELAY1 02 F544
    DELAY2 02 F551       DEN 00 DFF4      DEN1 00 DFF5        DF 02 E9E9
     DINIT 02 F4EF    DINIT1 02 F4F0    DINIT2 02 F4FE    DISFOS 02 E9A8
    DISRES 02 E719        DM 00 DFD6        DN 00 DFCE        DR 02 E75A
       DR1 02 E760     DRIVE 02 DF8E    DRIVE1 02 F4CC    DRIVE2 02 F4DA
    DROMSZ 00 DFFB    DRQBIT 00 0008       DRV 02 F4B7    DRVDT2 02 F367
    DRVERR 02 F389    DRVVEC 02 DFA9     DUMMY 02 F130     EBAUD 02 EED0
     EBRNK 02 EDDE     EBSMS 02 ED08 ENDDRVDT2 02 F382  ENDIDERW 02 F3F4
    ENDINI 02 F49A      ERR1 02 E8CD      ERR2 02 EB64    ERRBIT 00 0001
    ESCFLG 00 DFEB      FAST 02 F341      FCMD 02 F222        FI 02 ED1E
       FI1 02 ED40       FI2 02 ED57       FI3 02 ED65       FI4 02 ED73
       FI5 02 ED76       FI6 02 ED8F       FI7 02 EDA7       FI8 02 EDAF
     FIGG2 02 F6E0     FIGG3 02 F6F0     FIGS2 02 F6B9     FIGS3 02 F6C7
     FIGSF 02 F6A9     FIGSG 02 F6CE      FILL 02 F85D    FILMES 02 E501
     FIMES 02 ECF0      FIRQ 02 F124     FIRQV 02 DF86     FLASH 00 DFFD
      FLC2 02 FB61     FLCUR 02 FB4A        FM 02 E522       FM1 02 E541
       FMT 02 EA0D      FMT1 02 EA16      FMT2 02 EA38      FMT3 02 EA7D
      FMT4 02 EAA4      FMT5 02 EAB0     FROMS 02 E94F      GCOM 02 F641
     GCOM1 02 F646     GCOM2 02 F64F     GCRG1 02 F7C8     GCRG2 02 F7D1
     GCRG3 02 F7EB     GCRG4 02 F7F3       GDC 00 FF14     GDCI2 02 F8DB
    GDCINI 02 F8D3     GETA1 02 F193     GETA2 02 F199    GETCRG 02 F7B2
    GETCRT 02 FA85    GETRTC 02 F5EA    GETTIM 02 F5DD     GFIGS 00 DFCD
     GMODE 00 DFCB     GOFLX 02 E419    GPARAM 00 DFC3     GPCH2 02 FB6B
     GPCHR 02 FB63      GPRM 02 F653     GPRM2 02 F655     GPRMI 02 F662
     GRAPH 02 F814     GTIM2 02 F5E1     GZOOM 00 DFCC        HD 02 E5D2
       HD1 02 E5EF       HD2 02 E5F7       HD3 02 E606       HD4 02 E5DE
    HDCONT 02 E617    HDMES1 02 E59B       HDR 02 E000    HEXDUS 02 E581
    IDE_A0 00 0001    IDE_A1 00 0002    IDE_A2 00 0004 IDE_CMD_READ 00 0020
 IDE_CMD_SET_FEAT 00 00EF IDE_CMD_WRITE 00 0030 IDE_COMMAND 00 000F   IDE_CS0 00 0008
   IDE_CS1 00 0010  IDE_DATA 00 0008   IDE_ERR 00 0009 IDE_FEA_16BIT 00 0081
  IDE_LBA0 00 000B  IDE_LBA1 00 000C  IDE_LBA2 00 000D  IDE_LBA3 00 000E
    IDE_RD 00 0040   IDE_RST 00 0080 IDE_SEC_CNT 00 000A IDE_SET_FEAT 00 0009
 IDE_STATUS 00 000F    IDE_WR 00 0020    IGNORE 02 FC27     ILOOP 02 F473
    ILOOP1 02 F476      INC1 02 F155      INC2 02 F161      INCH 02 F16C
     INCH1 02 F153     INHEX 02 F58C    INHEX1 02 F5A1    INIDT2 02 F45F
     INIT2 02 E123     INIT3 02 E160     INIT4 02 E18C    INITXT 02 FAF2
    INIVEC 02 DFAF     INKEY 02 F18D        IO 00 FF00     IPORT 02 DF8C
       IRQ 02 F120      IRQV 02 DF84      IRTC 02 E119     ITRET 02 FB16
        JF 02 E2A3     JFMES 02 E289        JU 02 E27D     JUMES 02 E268
        L1 02 F09F      LBA0 02 DE7A      LBA1 02 DE7B      LBA2 02 DE7C
      LBA3 02 DE7D   LBA3MST 00 00E0   LBA3SLV 00 00F0     LDTB1 02 E3E7
     LDTB2 02 E3F7     LDTBL 02 E3E0    LENGHS 02 E7A6      LINE 02 F92B
     LINE1 02 F942     LINE2 02 F956     LINE3 02 F969        LK 02 E687
       LK1 02 E698    LOAKES 02 E65E   LOOPRST 02 E1B2     LOOPW 02 EFD4
    MAPOUT 02 F637      MASK 02 F66D        MC 02 ECAB       MC1 02 ECB6
       MC2 02 ECE0       MC3 02 ECE7     MCA02 00 CA02     MCMES 02 EC8E
     MDFC4 00 DFC4     MDFFA 00 DFFA        ME 02 E6E0       ME1 02 E6E9
       ME2 02 E6FD       MED 02 E703    MEMEXS 02 E6A4    MINIT1 02 E0EB
    MINITR 02 F0D9      MODE 02 F82F     MODE1 02 F842   MSTCFOK 02 DE7E
     MSTOK 02 F485      NEXT 02 F0FA     NEXT2 02 E3DD     NEXTB 02 E3C7
       NMI 02 F11C      NMIV 02 DF82     NOFLX 02 E30C      NOPE 02 F101
     NORAM 02 E6C5    NOTHEX 02 F5A2    NOTPRT 02 E615    NOTRDY 02 F45A
    NOTTHS 02 E02C    NVC0Z1 02 F336    NVZ0C1 02 F33B       OFF 02 F7FC
        ON 02 F808     OPORT 02 DF8D     OUT2H 02 F5A9    OUT2HA 02 F5AB
    OUT2HS 02 F5B3    OUT4HS 02 F5B1     OUTCH 02 F16E     OUTHL 02 F579
     OUTHR 02 F57D      OUTS 02 F5B5         P 02 F51B     P1TBL 02 F9A3
   PARMLOP 02 F39C     PARSE 02 F0F7     PART1 00 DFBB     PART2 00 DFBF
     PAUS1 02 F22A     PAUS2 02 F22D     PAUS3 02 F230     PAUSE 02 F227
     PBLIN 02 EC75     PCRLF 02 F512    PDATA1 02 F51E     PFAIL 02 E068
      PIA1 00 FF00      PIA2 00 FF1C        PM 02 E645     POINT 02 F91F
    POKMES 02 E634     PORTA 00 FF1C     PORTB 00 FF1D     PORTC 00 FF1E
  PORTCTRL 00 FF1F    PRINTA 02 F52A    PRINTX 02 F536      PROM 00 E000
    PROMPT 02 E027     PRTC2 02 F60A    PSPEED 00 DFF9    PSTRNG 02 F525
     PTIM2 02 F5FF     PUTA1 02 F1A2     PUTA2 02 F1AD    PUTRTC 02 F608
    PUTTIM 02 F5FB    PUTVID 02 F19F     QBUSY 02 F21A     QINT0 02 F1B8
     QINT1 02 F1BE     QINT2 02 F1C4     QUICK 02 F4EB    QUIVEC 02 DFAD
       RAM 00 DE00    RANDOM 02 F5BA     RDDT2 02 F3FB     RDFL1 02 F23F
     RDFL2 02 F24B     RDFL3 02 F251     RDFL4 02 F25A     RDFL5 02 F26F
     RDFLP 02 F231    RDLOOP 02 F407     RDSEC 02 E387       RDY 02 F455
    RDYBIT 00 0040 RD_IDE_8255 00 0092      READ 02 F4A2  READ_IDE 02 F3E2
    REASES 02 E8A0    REAVEC 02 DFA1      RECT 02 F9AB     REGDP 00 DFFC
     RESET 02 F08E      RNDM 02 DF98       ROW 00 DFD9        RP 02 E560
       RP1 02 E56F       RPT 02 F5BE        RS 02 E8E2     RSFLP 02 F2AE
       RST 02 F4AE      RST1 02 F4B3    RSTRNG 02 E731    RSTVEC 02 DFA7
       RTC 00 FF18   RTCFAIL 00 DFB5     RTCOK 02 E1A1    RUNPRS 02 E54D
    RWEXIT 02 F430        SB 02 EDF4       SB1 02 EE17       SB2 02 EE2C
       SB3 02 EE5D       SB4 02 EE6E     SBMES 02 EDB7     SBRMS 02 EDD0
     SCRAT 00 DF80     SCRD1 02 FCC6    SCRDWN 02 FCA9     SCRUP 02 FC8C
    SCRUP1 02 FC97    SCTCNT 02 DE79      SDEN 02 F2DD      SECS 02 E8C4
    SECTOR 02 DF90      SEEK 02 F50B    SEEVEC 02 DFB3     SELD0 02 F2FC
     SELD1 02 F306    SETCRG 02 F75B    SETCRT 02 FA68      SETD 02 F30E
    SETFEA 02 DE78    SETLBA 02 F38D     SETP2 02 F6A0    SETPAR 02 F6F7
    SETPAT 02 F696    SETPEN 02 F67F    SET_R0 00 FFD7    SET_R1 00 FFD9
    SHIMES 02 E789        SI 02 E2C3     SIMES 02 E2AF     SKFL1 02 F2E7
     SKFL2 02 F2E9     SKFLP 02 F2C4      SLOW 02 F34E     SLOW2 02 F366
   SLVCFOK 02 DE7F        SM 02 E7AF       SM1 02 E7D0        SO 02 E2E9
     SOMES 02 E2D4     SPEED 00 DFF7     SPRM2 02 F73F    SSTACK 00 DE6F
     STACK 02 DF80     STAT1 02 F143     STAT2 02 F148    STATUS 02 F131
      STEP 00 DFF6     SURES 02 E9D0       SWI 02 E574      SWI2 02 F128
     SWI2V 02 DF88      SWI3 02 F12C     SWI3V 02 DF8A    SYSREG 00 FF02
     TABIN 02 F17B    TABLE1 02 E41F    TABLE2 02 E437    TABOUT 02 F181
    TABSRT 02 F1CA     TBAUD 02 EE76    TCCACT 02 FBC1    TCONST 02 E0B9
        TD 02 EB75    TDLOOP 02 EB8D     TDLP2 02 EB9B     TDLP9 02 EBC0
     TDMES 02 EB31    TDMES1 02 EB4F      TEMP 02 DF91    TESMES 02 E7DD
      TEXT 02 FAA4   TFRPARM 02 F393       TL1 00 DFF0       TL2 00 DFF2
        TM 02 E825       TM1 02 E84E       TM2 02 E86E       TM3 02 E86B
       TM4 02 E854       TM5 02 E843      TMS1 02 E7F0      TMS2 02 E806
      TMS3 02 E812       TOS 02 E473     TQINT 02 F187     TRACK 02 DF8F
     TRACS 02 E8BC        TS 02 EBF6       TS1 00 DFEC       TS2 00 DFEE
    TSLOOP 02 EC08    TSMESS 02 EBDD     TSTEP 00 DFF8       TTO 02 DF96
     TTYBS 00 CC00    TXTRAM 00 CA00        U1 02 F0B3       U1L 02 F0BA
     UNEXP 02 F111    UNMESS 02 E040     UPDPA 02 FAFE    VALUES 02 E498
     VCRST 02 FFFE    VERIFY 02 F4AA    VERVEC 02 DFA5     VIDC1 02 FB28
     VIDC2 02 FB32     VIDC3 02 FB45     VIDCC 02 FBB5     VIDCH 02 FB1C
     VRFLP 02 F2A3     VSYN2 02 F74B     VSYN3 02 F752     VSYNC 02 F749
      WABT 02 EB28     WABT1 02 EB2A   WAIT1MS 02 EFD2      WARM 02 F507
     WARMS 02 DF9C    WARVEC 02 DFB1      WHAT 02 F109     WRDT2 02 F415
     WRFL1 02 F27F     WRFL2 02 F28B     WRFL3 02 F291     WRFL4 02 F29A
     WRFLP 02 F272    WRIMES 02 E934     WRITE 02 F4A6    WRIVEC 02 DFA3
    WRLOOP 02 F422   WRT_IDE 02 F3CA WR_IDE_8255 00 0080        WS 02 E956
    XCOORD 00 DFB7     XTEMP 02 DF92    YCOORD 00 DFB9     YTEMP 02 DF94
      ZOOM 02 F846     ZOOM1 02 F859
538 SYMBOLS

0 error(s), 0 warning(s)
